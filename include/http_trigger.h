// Generated by `wit-bindgen` 0.16.0. DO NOT EDIT!
#ifndef __BINDINGS_HTTP_TRIGGER_H
#define __BINDINGS_HTTP_TRIGGER_H
#ifdef __cplusplus
extern "C" {
#endif

#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>

typedef struct {
  uint8_t*ptr;
  size_t len;
} http_trigger_string_t;

typedef struct wasi_io_0_2_0_rc_2023_10_18_poll_own_pollable_t {
  int32_t __handle;
} wasi_io_0_2_0_rc_2023_10_18_poll_own_pollable_t;

typedef struct wasi_io_0_2_0_rc_2023_10_18_poll_borrow_pollable_t {
  int32_t __handle;
} wasi_io_0_2_0_rc_2023_10_18_poll_borrow_pollable_t;

typedef struct {
  wasi_io_0_2_0_rc_2023_10_18_poll_borrow_pollable_t *ptr;
  size_t len;
} wasi_io_0_2_0_rc_2023_10_18_poll_list_borrow_pollable_t;

typedef struct {
  uint32_t *ptr;
  size_t len;
} wasi_io_0_2_0_rc_2023_10_18_poll_list_u32_t;

typedef struct wasi_io_0_2_0_rc_2023_10_18_streams_own_error_t {
  int32_t __handle;
} wasi_io_0_2_0_rc_2023_10_18_streams_own_error_t;

typedef struct wasi_io_0_2_0_rc_2023_10_18_streams_borrow_error_t {
  int32_t __handle;
} wasi_io_0_2_0_rc_2023_10_18_streams_borrow_error_t;

// An error for input-stream and output-stream operations.
typedef struct {
  uint8_t tag;
  union {
    wasi_io_0_2_0_rc_2023_10_18_streams_own_error_t last_operation_failed;
  } val;
} wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t;

// The last operation (a write or flush) failed before completion.
// 
// More information is available in the `error` payload.
#define WASI_IO_0_2_0_RC_2023_10_18_STREAMS_STREAM_ERROR_LAST_OPERATION_FAILED 0
// The stream is closed: no more input will be accepted by the
// stream. A closed output-stream will return this error on all
// future operations.
#define WASI_IO_0_2_0_RC_2023_10_18_STREAMS_STREAM_ERROR_CLOSED 1

typedef struct wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t {
  int32_t __handle;
} wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t;

typedef struct wasi_io_0_2_0_rc_2023_10_18_streams_borrow_input_stream_t {
  int32_t __handle;
} wasi_io_0_2_0_rc_2023_10_18_streams_borrow_input_stream_t;

typedef struct wasi_io_0_2_0_rc_2023_10_18_streams_own_output_stream_t {
  int32_t __handle;
} wasi_io_0_2_0_rc_2023_10_18_streams_own_output_stream_t;

typedef struct wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t {
  int32_t __handle;
} wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} wasi_io_0_2_0_rc_2023_10_18_streams_list_u8_t;

typedef struct {
  bool is_err;
  union {
    wasi_io_0_2_0_rc_2023_10_18_streams_list_u8_t ok;
    wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t err;
  } val;
} wasi_io_0_2_0_rc_2023_10_18_streams_result_list_u8_stream_error_t;

typedef struct {
  bool is_err;
  union {
    uint64_t ok;
    wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t err;
  } val;
} wasi_io_0_2_0_rc_2023_10_18_streams_result_u64_stream_error_t;

typedef wasi_io_0_2_0_rc_2023_10_18_poll_own_pollable_t wasi_io_0_2_0_rc_2023_10_18_streams_own_pollable_t;

typedef struct {
  bool is_err;
  union {
    wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t err;
  } val;
} wasi_io_0_2_0_rc_2023_10_18_streams_result_void_stream_error_t;

// This type corresponds to HTTP standard Methods.
typedef struct {
  uint8_t tag;
  union {
    http_trigger_string_t other;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_types_method_t;

#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_METHOD_GET 0
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_METHOD_HEAD 1
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_METHOD_POST 2
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_METHOD_PUT 3
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_METHOD_DELETE 4
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_METHOD_CONNECT 5
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_METHOD_OPTIONS 6
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_METHOD_TRACE 7
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_METHOD_PATCH 8
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_METHOD_OTHER 9

// This type corresponds to HTTP standard Related Schemes.
typedef struct {
  uint8_t tag;
  union {
    http_trigger_string_t other;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_types_scheme_t;

#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_SCHEME_HTTP 0
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_SCHEME_HTTPS 1
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_SCHEME_OTHER 2

// TODO: perhaps better align with HTTP semantics?
// This type enumerates the different kinds of errors that may occur when
// initially returning a response.
typedef struct {
  uint8_t tag;
  union {
    http_trigger_string_t invalid_url;
    http_trigger_string_t timeout_error;
    http_trigger_string_t protocol_error;
    http_trigger_string_t unexpected_error;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_types_error_t;

#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_ERROR_INVALID_URL 0
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_ERROR_TIMEOUT_ERROR 1
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_ERROR_PROTOCOL_ERROR 2
#define WASI_HTTP_0_2_0_RC_2023_10_18_TYPES_ERROR_UNEXPECTED_ERROR 3

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_own_fields_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_own_fields_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_borrow_fields_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_borrow_fields_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_request_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_request_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_request_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_request_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_request_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_request_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_request_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_request_t;

typedef struct {
  bool is_some;
  uint32_t val;
} wasi_http_0_2_0_rc_2023_10_18_types_option_u32_t;

// Additional optional parameters that can be set when making a request.
typedef struct {
  // The following timeouts are specific to the HTTP protocol and work
  // independently of the overall timeouts passed to `io.poll.poll-list`.
  // The timeout for the initial connect.
  wasi_http_0_2_0_rc_2023_10_18_types_option_u32_t connect_timeout_ms;
  // The timeout for receiving the first byte of the response body.
  wasi_http_0_2_0_rc_2023_10_18_types_option_u32_t first_byte_timeout_ms;
  // The timeout for receiving the next chunk of bytes in the response body
  // stream.
  wasi_http_0_2_0_rc_2023_10_18_types_option_u32_t between_bytes_timeout_ms;
} wasi_http_0_2_0_rc_2023_10_18_types_request_options_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_own_response_outparam_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_own_response_outparam_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_borrow_response_outparam_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_borrow_response_outparam_t;

// This type corresponds to the HTTP standard Status Code.
typedef uint16_t wasi_http_0_2_0_rc_2023_10_18_types_status_code_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_response_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_response_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_response_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_response_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_body_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_body_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_body_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_body_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_own_future_trailers_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_own_future_trailers_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_trailers_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_trailers_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_response_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_response_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_response_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_response_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_body_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_body_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_body_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_body_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_own_future_incoming_response_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_own_future_incoming_response_t;

typedef struct wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_incoming_response_t {
  int32_t __handle;
} wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_incoming_response_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} wasi_http_0_2_0_rc_2023_10_18_types_list_u8_t;

typedef struct {
  http_trigger_string_t f0;
  wasi_http_0_2_0_rc_2023_10_18_types_list_u8_t f1;
} wasi_http_0_2_0_rc_2023_10_18_types_tuple2_string_list_u8_t;

typedef struct {
  wasi_http_0_2_0_rc_2023_10_18_types_tuple2_string_list_u8_t *ptr;
  size_t len;
} wasi_http_0_2_0_rc_2023_10_18_types_list_tuple2_string_list_u8_t;

typedef struct {
  wasi_http_0_2_0_rc_2023_10_18_types_list_u8_t *ptr;
  size_t len;
} wasi_http_0_2_0_rc_2023_10_18_types_list_list_u8_t;

typedef struct {
  bool is_some;
  http_trigger_string_t val;
} wasi_http_0_2_0_rc_2023_10_18_types_option_string_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_rc_2023_10_18_types_scheme_t val;
} wasi_http_0_2_0_rc_2023_10_18_types_option_scheme_t;

typedef wasi_http_0_2_0_rc_2023_10_18_types_own_fields_t wasi_http_0_2_0_rc_2023_10_18_types_own_headers_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_body_t ok;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_types_result_own_incoming_body_void_t;

typedef wasi_http_0_2_0_rc_2023_10_18_types_borrow_fields_t wasi_http_0_2_0_rc_2023_10_18_types_borrow_headers_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_body_t ok;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_types_result_own_outgoing_body_void_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_response_t ok;
    wasi_http_0_2_0_rc_2023_10_18_types_error_t err;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_types_result_own_outgoing_response_error_t;

typedef wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t wasi_http_0_2_0_rc_2023_10_18_types_own_input_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_rc_2023_10_18_types_own_input_stream_t ok;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_types_result_own_input_stream_void_t;

typedef wasi_io_0_2_0_rc_2023_10_18_poll_own_pollable_t wasi_http_0_2_0_rc_2023_10_18_types_own_pollable_t;

typedef wasi_http_0_2_0_rc_2023_10_18_types_own_fields_t wasi_http_0_2_0_rc_2023_10_18_types_own_trailers_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_rc_2023_10_18_types_own_trailers_t ok;
    wasi_http_0_2_0_rc_2023_10_18_types_error_t err;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_types_result_own_trailers_error_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_rc_2023_10_18_types_result_own_trailers_error_t val;
} wasi_http_0_2_0_rc_2023_10_18_types_option_result_own_trailers_error_t;

typedef wasi_io_0_2_0_rc_2023_10_18_streams_own_output_stream_t wasi_http_0_2_0_rc_2023_10_18_types_own_output_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_rc_2023_10_18_types_own_output_stream_t ok;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_types_result_own_output_stream_void_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_rc_2023_10_18_types_own_trailers_t val;
} wasi_http_0_2_0_rc_2023_10_18_types_option_own_trailers_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_response_t ok;
    wasi_http_0_2_0_rc_2023_10_18_types_error_t err;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_types_result_own_incoming_response_error_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_rc_2023_10_18_types_result_own_incoming_response_error_t ok;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_types_result_result_own_incoming_response_error_void_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_rc_2023_10_18_types_result_result_own_incoming_response_error_void_t val;
} wasi_http_0_2_0_rc_2023_10_18_types_option_result_result_own_incoming_response_error_void_t;

typedef wasi_http_0_2_0_rc_2023_10_18_types_request_options_t wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_request_options_t;

typedef wasi_http_0_2_0_rc_2023_10_18_types_error_t wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_error_t;

typedef wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_request_t wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_own_outgoing_request_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_request_options_t val;
} wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_option_request_options_t;

typedef wasi_http_0_2_0_rc_2023_10_18_types_own_future_incoming_response_t wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_own_future_incoming_response_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_own_future_incoming_response_t ok;
    wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_error_t err;
  } val;
} wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_result_own_future_incoming_response_error_t;

// A Large Language Model.
typedef http_trigger_string_t fermyon_spin_2_0_0_llm_inferencing_model_t;

// Inference request parameters
typedef struct {
  // The maximum tokens that should be inferred.
  // 
  // Note: the backing implementation may return less tokens.
  uint32_t max_tokens;
  // The amount the model should avoid repeating tokens.
  float repeat_penalty;
  // The number of tokens the model should apply the repeat penalty to.
  uint32_t repeat_penalty_last_n_token_count;
  // The randomness with which the next token is selected.
  float temperature;
  // The number of possible next tokens the model will choose from.
  uint32_t top_k;
  // The probability total of next tokens the model will choose from.
  float top_p;
} fermyon_spin_2_0_0_llm_inferencing_params_t;

// The set of errors which may be raised by functions in this interface
typedef struct {
  uint8_t tag;
  union {
    http_trigger_string_t runtime_error;
    http_trigger_string_t invalid_input;
  } val;
} fermyon_spin_2_0_0_llm_error_t;

#define FERMYON_SPIN_2_0_0_LLM_ERROR_MODEL_NOT_SUPPORTED 0
#define FERMYON_SPIN_2_0_0_LLM_ERROR_RUNTIME_ERROR 1
#define FERMYON_SPIN_2_0_0_LLM_ERROR_INVALID_INPUT 2

// Usage information related to the inferencing result
typedef struct {
  // Number of tokens in the prompt
  uint32_t prompt_token_count;
  // Number of tokens generated by the inferencing operation
  uint32_t generated_token_count;
} fermyon_spin_2_0_0_llm_inferencing_usage_t;

// An inferencing result
typedef struct {
  // The text generated by the model
  // TODO: this should be a stream
  http_trigger_string_t text;
  // Usage information about the inferencing request
  fermyon_spin_2_0_0_llm_inferencing_usage_t usage;
} fermyon_spin_2_0_0_llm_inferencing_result_t;

// The model used for generating embeddings
typedef http_trigger_string_t fermyon_spin_2_0_0_llm_embedding_model_t;

// Usage related to an embeddings generation request
typedef struct {
  // Number of tokens in the prompt
  uint32_t prompt_token_count;
} fermyon_spin_2_0_0_llm_embeddings_usage_t;

typedef struct {
  float *ptr;
  size_t len;
} fermyon_spin_2_0_0_llm_list_float32_t;

typedef struct {
  fermyon_spin_2_0_0_llm_list_float32_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_llm_list_list_float32_t;

// Result of generating embeddings
typedef struct {
  // The embeddings generated by the request
  fermyon_spin_2_0_0_llm_list_list_float32_t embeddings;
  // Usage related to the embeddings generation request
  fermyon_spin_2_0_0_llm_embeddings_usage_t usage;
} fermyon_spin_2_0_0_llm_embeddings_result_t;

typedef struct {
  bool is_some;
  fermyon_spin_2_0_0_llm_inferencing_params_t val;
} fermyon_spin_2_0_0_llm_option_inferencing_params_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_llm_inferencing_result_t ok;
    fermyon_spin_2_0_0_llm_error_t err;
  } val;
} fermyon_spin_2_0_0_llm_result_inferencing_result_error_t;

typedef struct {
  http_trigger_string_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_llm_list_string_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_llm_embeddings_result_t ok;
    fermyon_spin_2_0_0_llm_error_t err;
  } val;
} fermyon_spin_2_0_0_llm_result_embeddings_result_error_t;

// Errors related to interacting with Redis
typedef struct {
  uint8_t tag;
  union {
    http_trigger_string_t other;
  } val;
} fermyon_spin_2_0_0_redis_error_t;

// An invalid address string
#define FERMYON_SPIN_2_0_0_REDIS_ERROR_INVALID_ADDRESS 0
// There are too many open connections
#define FERMYON_SPIN_2_0_0_REDIS_ERROR_TOO_MANY_CONNECTIONS 1
// A retrieved value was not of the correct type
#define FERMYON_SPIN_2_0_0_REDIS_ERROR_TYPE_ERROR 2
// Some other error occurred
#define FERMYON_SPIN_2_0_0_REDIS_ERROR_OTHER 3

typedef struct fermyon_spin_2_0_0_redis_own_connection_t {
  int32_t __handle;
} fermyon_spin_2_0_0_redis_own_connection_t;

typedef struct fermyon_spin_2_0_0_redis_borrow_connection_t {
  int32_t __handle;
} fermyon_spin_2_0_0_redis_borrow_connection_t;

// The message payload.
typedef struct {
  uint8_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_redis_payload_t;

// A parameter type for the general-purpose `execute` function.
typedef struct {
  uint8_t tag;
  union {
    int64_t int64;
    fermyon_spin_2_0_0_redis_payload_t binary;
  } val;
} fermyon_spin_2_0_0_redis_redis_parameter_t;

#define FERMYON_SPIN_2_0_0_REDIS_REDIS_PARAMETER_INT64 0
#define FERMYON_SPIN_2_0_0_REDIS_REDIS_PARAMETER_BINARY 1

// A return type for the general-purpose `execute` function.
typedef struct {
  uint8_t tag;
  union {
    http_trigger_string_t status;
    int64_t int64;
    fermyon_spin_2_0_0_redis_payload_t binary;
  } val;
} fermyon_spin_2_0_0_redis_redis_result_t;

#define FERMYON_SPIN_2_0_0_REDIS_REDIS_RESULT_NIL 0
#define FERMYON_SPIN_2_0_0_REDIS_REDIS_RESULT_STATUS 1
#define FERMYON_SPIN_2_0_0_REDIS_REDIS_RESULT_INT64 2
#define FERMYON_SPIN_2_0_0_REDIS_REDIS_RESULT_BINARY 3

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_redis_own_connection_t ok;
    fermyon_spin_2_0_0_redis_error_t err;
  } val;
} fermyon_spin_2_0_0_redis_result_own_connection_error_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_redis_error_t err;
  } val;
} fermyon_spin_2_0_0_redis_result_void_error_t;

typedef struct {
  bool is_some;
  fermyon_spin_2_0_0_redis_payload_t val;
} fermyon_spin_2_0_0_redis_option_payload_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_redis_option_payload_t ok;
    fermyon_spin_2_0_0_redis_error_t err;
  } val;
} fermyon_spin_2_0_0_redis_result_option_payload_error_t;

typedef struct {
  bool is_err;
  union {
    int64_t ok;
    fermyon_spin_2_0_0_redis_error_t err;
  } val;
} fermyon_spin_2_0_0_redis_result_s64_error_t;

typedef struct {
  bool is_err;
  union {
    uint32_t ok;
    fermyon_spin_2_0_0_redis_error_t err;
  } val;
} fermyon_spin_2_0_0_redis_result_u32_error_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_llm_list_string_t ok;
    fermyon_spin_2_0_0_redis_error_t err;
  } val;
} fermyon_spin_2_0_0_redis_result_list_string_error_t;

typedef struct {
  fermyon_spin_2_0_0_redis_redis_parameter_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_redis_list_redis_parameter_t;

typedef struct {
  fermyon_spin_2_0_0_redis_redis_result_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_redis_list_redis_result_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_redis_list_redis_result_t ok;
    fermyon_spin_2_0_0_redis_error_t err;
  } val;
} fermyon_spin_2_0_0_redis_result_list_redis_result_error_t;

// Errors related to interacting with a database.
typedef struct {
  uint8_t tag;
  union {
    http_trigger_string_t connection_failed;
    http_trigger_string_t bad_parameter;
    http_trigger_string_t query_failed;
    http_trigger_string_t value_conversion_failed;
    http_trigger_string_t other;
  } val;
} fermyon_spin_2_0_0_rdbms_types_error_t;

#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_ERROR_CONNECTION_FAILED 0
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_ERROR_BAD_PARAMETER 1
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_ERROR_QUERY_FAILED 2
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_ERROR_VALUE_CONVERSION_FAILED 3
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_ERROR_OTHER 4

// Data types for a database column
typedef uint8_t fermyon_spin_2_0_0_rdbms_types_db_data_type_t;

#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_BOOLEAN 0
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_INT8 1
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_INT16 2
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_INT32 3
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_INT64 4
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_UINT8 5
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_UINT16 6
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_UINT32 7
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_UINT64 8
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_FLOATING32 9
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_FLOATING64 10
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_STR 11
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_BINARY 12
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_DATA_TYPE_OTHER 13

typedef struct {
  uint8_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_rdbms_types_list_u8_t;

// Database values
typedef struct {
  uint8_t tag;
  union {
    bool boolean;
    int8_t int8;
    int16_t int16;
    int32_t int32;
    int64_t int64;
    uint8_t uint8;
    uint16_t uint16;
    uint32_t uint32;
    uint64_t uint64;
    float floating32;
    double floating64;
    http_trigger_string_t str;
    fermyon_spin_2_0_0_rdbms_types_list_u8_t binary;
  } val;
} fermyon_spin_2_0_0_rdbms_types_db_value_t;

#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_BOOLEAN 0
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_INT8 1
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_INT16 2
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_INT32 3
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_INT64 4
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_UINT8 5
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_UINT16 6
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_UINT32 7
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_UINT64 8
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_FLOATING32 9
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_FLOATING64 10
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_STR 11
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_BINARY 12
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_DB_NULL 13
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_DB_VALUE_UNSUPPORTED 14

// Values used in parameterized queries
typedef struct {
  uint8_t tag;
  union {
    bool boolean;
    int8_t int8;
    int16_t int16;
    int32_t int32;
    int64_t int64;
    uint8_t uint8;
    uint16_t uint16;
    uint32_t uint32;
    uint64_t uint64;
    float floating32;
    double floating64;
    http_trigger_string_t str;
    fermyon_spin_2_0_0_rdbms_types_list_u8_t binary;
  } val;
} fermyon_spin_2_0_0_rdbms_types_parameter_value_t;

#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_BOOLEAN 0
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_INT8 1
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_INT16 2
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_INT32 3
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_INT64 4
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_UINT8 5
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_UINT16 6
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_UINT32 7
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_UINT64 8
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_FLOATING32 9
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_FLOATING64 10
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_STR 11
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_BINARY 12
#define FERMYON_SPIN_2_0_0_RDBMS_TYPES_PARAMETER_VALUE_DB_NULL 13

// A database column
typedef struct {
  http_trigger_string_t name;
  fermyon_spin_2_0_0_rdbms_types_db_data_type_t data_type;
} fermyon_spin_2_0_0_rdbms_types_column_t;

// A database row
typedef struct {
  fermyon_spin_2_0_0_rdbms_types_db_value_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_rdbms_types_row_t;

typedef struct {
  fermyon_spin_2_0_0_rdbms_types_column_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_rdbms_types_list_column_t;

typedef struct {
  fermyon_spin_2_0_0_rdbms_types_row_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_rdbms_types_list_row_t;

// A set of database rows
typedef struct {
  fermyon_spin_2_0_0_rdbms_types_list_column_t columns;
  fermyon_spin_2_0_0_rdbms_types_list_row_t rows;
} fermyon_spin_2_0_0_rdbms_types_row_set_t;

typedef fermyon_spin_2_0_0_rdbms_types_parameter_value_t fermyon_spin_2_0_0_postgres_parameter_value_t;

typedef fermyon_spin_2_0_0_rdbms_types_row_set_t fermyon_spin_2_0_0_postgres_row_set_t;

typedef fermyon_spin_2_0_0_rdbms_types_error_t fermyon_spin_2_0_0_postgres_error_t;

typedef struct fermyon_spin_2_0_0_postgres_own_connection_t {
  int32_t __handle;
} fermyon_spin_2_0_0_postgres_own_connection_t;

typedef struct fermyon_spin_2_0_0_postgres_borrow_connection_t {
  int32_t __handle;
} fermyon_spin_2_0_0_postgres_borrow_connection_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_postgres_own_connection_t ok;
    fermyon_spin_2_0_0_postgres_error_t err;
  } val;
} fermyon_spin_2_0_0_postgres_result_own_connection_error_t;

typedef struct {
  fermyon_spin_2_0_0_postgres_parameter_value_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_postgres_list_parameter_value_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_postgres_row_set_t ok;
    fermyon_spin_2_0_0_postgres_error_t err;
  } val;
} fermyon_spin_2_0_0_postgres_result_row_set_error_t;

typedef struct {
  bool is_err;
  union {
    uint64_t ok;
    fermyon_spin_2_0_0_postgres_error_t err;
  } val;
} fermyon_spin_2_0_0_postgres_result_u64_error_t;

typedef fermyon_spin_2_0_0_rdbms_types_parameter_value_t fermyon_spin_2_0_0_mysql_parameter_value_t;

typedef fermyon_spin_2_0_0_rdbms_types_row_set_t fermyon_spin_2_0_0_mysql_row_set_t;

typedef fermyon_spin_2_0_0_rdbms_types_error_t fermyon_spin_2_0_0_mysql_error_t;

typedef struct fermyon_spin_2_0_0_mysql_own_connection_t {
  int32_t __handle;
} fermyon_spin_2_0_0_mysql_own_connection_t;

typedef struct fermyon_spin_2_0_0_mysql_borrow_connection_t {
  int32_t __handle;
} fermyon_spin_2_0_0_mysql_borrow_connection_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_mysql_own_connection_t ok;
    fermyon_spin_2_0_0_mysql_error_t err;
  } val;
} fermyon_spin_2_0_0_mysql_result_own_connection_error_t;

typedef struct {
  fermyon_spin_2_0_0_mysql_parameter_value_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_mysql_list_parameter_value_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_mysql_row_set_t ok;
    fermyon_spin_2_0_0_mysql_error_t err;
  } val;
} fermyon_spin_2_0_0_mysql_result_row_set_error_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_mysql_error_t err;
  } val;
} fermyon_spin_2_0_0_mysql_result_void_error_t;

typedef struct fermyon_spin_2_0_0_sqlite_own_connection_t {
  int32_t __handle;
} fermyon_spin_2_0_0_sqlite_own_connection_t;

typedef struct fermyon_spin_2_0_0_sqlite_borrow_connection_t {
  int32_t __handle;
} fermyon_spin_2_0_0_sqlite_borrow_connection_t;

// The set of errors which may be raised by functions in this interface
typedef struct {
  uint8_t tag;
  union {
    http_trigger_string_t io;
  } val;
} fermyon_spin_2_0_0_sqlite_error_t;

// The host does not recognize the database name requested.
#define FERMYON_SPIN_2_0_0_SQLITE_ERROR_NO_SUCH_DATABASE 0
// The requesting component does not have access to the specified database (which may or may not exist).
#define FERMYON_SPIN_2_0_0_SQLITE_ERROR_ACCESS_DENIED 1
// The provided connection is not valid
#define FERMYON_SPIN_2_0_0_SQLITE_ERROR_INVALID_CONNECTION 2
// The database has reached its capacity
#define FERMYON_SPIN_2_0_0_SQLITE_ERROR_DATABASE_FULL 3
// Some implementation-specific error has occurred (e.g. I/O)
#define FERMYON_SPIN_2_0_0_SQLITE_ERROR_IO 4

// A single column's result from a database query
typedef struct {
  uint8_t tag;
  union {
    int64_t integer;
    double real;
    http_trigger_string_t text;
    fermyon_spin_2_0_0_rdbms_types_list_u8_t blob;
  } val;
} fermyon_spin_2_0_0_sqlite_value_t;

#define FERMYON_SPIN_2_0_0_SQLITE_VALUE_INTEGER 0
#define FERMYON_SPIN_2_0_0_SQLITE_VALUE_REAL 1
#define FERMYON_SPIN_2_0_0_SQLITE_VALUE_TEXT 2
#define FERMYON_SPIN_2_0_0_SQLITE_VALUE_BLOB 3
#define FERMYON_SPIN_2_0_0_SQLITE_VALUE_NULL 4

typedef struct {
  fermyon_spin_2_0_0_sqlite_value_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_sqlite_list_value_t;

// A set of values for each of the columns in a query-result
typedef struct {
  fermyon_spin_2_0_0_sqlite_list_value_t values;
} fermyon_spin_2_0_0_sqlite_row_result_t;

typedef struct {
  fermyon_spin_2_0_0_sqlite_row_result_t *ptr;
  size_t len;
} fermyon_spin_2_0_0_sqlite_list_row_result_t;

// A result of a query
typedef struct {
  // The names of the columns retrieved in the query
  fermyon_spin_2_0_0_llm_list_string_t columns;
  // the row results each containing the values for all the columns for a given row
  fermyon_spin_2_0_0_sqlite_list_row_result_t rows;
} fermyon_spin_2_0_0_sqlite_query_result_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_sqlite_own_connection_t ok;
    fermyon_spin_2_0_0_sqlite_error_t err;
  } val;
} fermyon_spin_2_0_0_sqlite_result_own_connection_error_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_sqlite_query_result_t ok;
    fermyon_spin_2_0_0_sqlite_error_t err;
  } val;
} fermyon_spin_2_0_0_sqlite_result_query_result_error_t;

typedef struct fermyon_spin_2_0_0_key_value_own_store_t {
  int32_t __handle;
} fermyon_spin_2_0_0_key_value_own_store_t;

typedef struct fermyon_spin_2_0_0_key_value_borrow_store_t {
  int32_t __handle;
} fermyon_spin_2_0_0_key_value_borrow_store_t;

// The set of errors which may be raised by functions in this interface
typedef struct {
  uint8_t tag;
  union {
    http_trigger_string_t other;
  } val;
} fermyon_spin_2_0_0_key_value_error_t;

// Too many stores have been opened simultaneously. Closing one or more
// stores prior to retrying may address this.
#define FERMYON_SPIN_2_0_0_KEY_VALUE_ERROR_STORE_TABLE_FULL 0
// The host does not recognize the store label requested.
#define FERMYON_SPIN_2_0_0_KEY_VALUE_ERROR_NO_SUCH_STORE 1
// The requesting component does not have access to the specified store
// (which may or may not exist).
#define FERMYON_SPIN_2_0_0_KEY_VALUE_ERROR_ACCESS_DENIED 2
// Some implementation-specific error has occurred (e.g. I/O)
#define FERMYON_SPIN_2_0_0_KEY_VALUE_ERROR_OTHER 3

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_key_value_own_store_t ok;
    fermyon_spin_2_0_0_key_value_error_t err;
  } val;
} fermyon_spin_2_0_0_key_value_result_own_store_error_t;

typedef struct {
  bool is_some;
  fermyon_spin_2_0_0_rdbms_types_list_u8_t val;
} fermyon_spin_2_0_0_key_value_option_list_u8_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_key_value_option_list_u8_t ok;
    fermyon_spin_2_0_0_key_value_error_t err;
  } val;
} fermyon_spin_2_0_0_key_value_result_option_list_u8_error_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_key_value_error_t err;
  } val;
} fermyon_spin_2_0_0_key_value_result_void_error_t;

typedef struct {
  bool is_err;
  union {
    bool ok;
    fermyon_spin_2_0_0_key_value_error_t err;
  } val;
} fermyon_spin_2_0_0_key_value_result_bool_error_t;

typedef struct {
  bool is_err;
  union {
    fermyon_spin_2_0_0_llm_list_string_t ok;
    fermyon_spin_2_0_0_key_value_error_t err;
  } val;
} fermyon_spin_2_0_0_key_value_result_list_string_error_t;

// The set of errors which may be raised by functions in this interface.
typedef struct {
  uint8_t tag;
  union {
    http_trigger_string_t invalid_name;
    http_trigger_string_t undefined;
    http_trigger_string_t provider;
    http_trigger_string_t other;
  } val;
} fermyon_spin_2_0_0_variables_error_t;

// The provided variable name is invalid.
#define FERMYON_SPIN_2_0_0_VARIABLES_ERROR_INVALID_NAME 0
// The provided variable is undefined.
#define FERMYON_SPIN_2_0_0_VARIABLES_ERROR_UNDEFINED 1
// A variables provider specific error has occurred.
#define FERMYON_SPIN_2_0_0_VARIABLES_ERROR_PROVIDER 2
// Some implementation-specific error has occurred.
#define FERMYON_SPIN_2_0_0_VARIABLES_ERROR_OTHER 3

typedef struct {
  bool is_err;
  union {
    http_trigger_string_t ok;
    fermyon_spin_2_0_0_variables_error_t err;
  } val;
} fermyon_spin_2_0_0_variables_result_string_error_t;

// A time and date in seconds plus nanoseconds.
typedef struct {
  uint64_t seconds;
  uint32_t nanoseconds;
} wasi_clocks_0_2_0_rc_2023_10_18_wall_clock_datetime_t;

// A timestamp in nanoseconds.
typedef uint64_t wasi_clocks_0_2_0_rc_2023_10_18_monotonic_clock_instant_t;

typedef wasi_io_0_2_0_rc_2023_10_18_poll_own_pollable_t wasi_clocks_0_2_0_rc_2023_10_18_monotonic_clock_own_pollable_t;

typedef wasi_clocks_0_2_0_rc_2023_10_18_wall_clock_datetime_t wasi_clocks_0_2_0_rc_2023_10_18_timezone_datetime_t;

// Information useful for displaying the timezone of a specific `datetime`.
// 
// This information may vary within a single `timezone` to reflect daylight
// saving time adjustments.
typedef struct {
  // The number of seconds difference between UTC time and the local
  // time of the timezone.
  // 
  // The returned value will always be less than 86400 which is the
  // number of seconds in a day (24*60*60).
  // 
  // In implementations that do not expose an actual time zone, this
  // should return 0.
  int32_t utc_offset;
  // The abbreviated name of the timezone to display to a user. The name
  // `UTC` indicates Coordinated Universal Time. Otherwise, this should
  // reference local standards for the name of the time zone.
  // 
  // In implementations that do not expose an actual time zone, this
  // should be the string `UTC`.
  // 
  // In time zones that do not have an applicable name, a formatted
  // representation of the UTC offset may be returned, such as `-04:00`.
  http_trigger_string_t name;
  // Whether daylight saving time is active.
  // 
  // In implementations that do not expose an actual time zone, this
  // should return false.
  bool in_daylight_saving_time;
} wasi_clocks_0_2_0_rc_2023_10_18_timezone_timezone_display_t;

typedef wasi_clocks_0_2_0_rc_2023_10_18_wall_clock_datetime_t wasi_filesystem_0_2_0_rc_2023_10_18_types_datetime_t;

// File size or length of a region within a file.
typedef uint64_t wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t;

// The type of a filesystem object referenced by a descriptor.
// 
// Note: This was called `filetype` in earlier versions of WASI.
typedef uint8_t wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_type_t;

// The type of the descriptor or file is unknown or is different from
// any of the other types specified.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_TYPE_UNKNOWN 0
// The descriptor refers to a block device inode.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_TYPE_BLOCK_DEVICE 1
// The descriptor refers to a character device inode.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_TYPE_CHARACTER_DEVICE 2
// The descriptor refers to a directory inode.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_TYPE_DIRECTORY 3
// The descriptor refers to a named pipe.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_TYPE_FIFO 4
// The file refers to a symbolic link inode.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_TYPE_SYMBOLIC_LINK 5
// The descriptor refers to a regular file inode.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_TYPE_REGULAR_FILE 6
// The descriptor refers to a socket.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_TYPE_SOCKET 7

// Descriptor flags.
// 
// Note: This was called `fdflags` in earlier versions of WASI.
typedef uint8_t wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_flags_t;

// Read mode: Data can be read.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_FLAGS_READ (1 << 0)
// Write mode: Data can be written to.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_FLAGS_WRITE (1 << 1)
// Request that writes be performed according to synchronized I/O file
// integrity completion. The data stored in the file and the file's
// metadata are synchronized. This is similar to `O_SYNC` in POSIX.
// 
// The precise semantics of this operation have not yet been defined for
// WASI. At this time, it should be interpreted as a request, and not a
// requirement.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_FLAGS_FILE_INTEGRITY_SYNC (1 << 2)
// Request that writes be performed according to synchronized I/O data
// integrity completion. Only the data stored in the file is
// synchronized. This is similar to `O_DSYNC` in POSIX.
// 
// The precise semantics of this operation have not yet been defined for
// WASI. At this time, it should be interpreted as a request, and not a
// requirement.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_FLAGS_DATA_INTEGRITY_SYNC (1 << 3)
// Requests that reads be performed at the same level of integrety
// requested for writes. This is similar to `O_RSYNC` in POSIX.
// 
// The precise semantics of this operation have not yet been defined for
// WASI. At this time, it should be interpreted as a request, and not a
// requirement.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_FLAGS_REQUESTED_WRITE_SYNC (1 << 4)
// Mutating directories mode: Directory contents may be mutated.
// 
// When this flag is unset on a descriptor, operations using the
// descriptor which would create, rename, delete, modify the data or
// metadata of filesystem objects, or obtain another handle which
// would permit any of those, shall fail with `error-code::read-only` if
// they would otherwise succeed.
// 
// This may only be set on directories.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_DESCRIPTOR_FLAGS_MUTATE_DIRECTORY (1 << 5)

// Flags determining the method of how paths are resolved.
typedef uint8_t wasi_filesystem_0_2_0_rc_2023_10_18_types_path_flags_t;

// As long as the resolved path corresponds to a symbolic link, it is
// expanded.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_PATH_FLAGS_SYMLINK_FOLLOW (1 << 0)

// Open flags used by `open-at`.
typedef uint8_t wasi_filesystem_0_2_0_rc_2023_10_18_types_open_flags_t;

// Create file if it does not exist, similar to `O_CREAT` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_OPEN_FLAGS_CREATE (1 << 0)
// Fail if not a directory, similar to `O_DIRECTORY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_OPEN_FLAGS_DIRECTORY (1 << 1)
// Fail if file already exists, similar to `O_EXCL` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_OPEN_FLAGS_EXCLUSIVE (1 << 2)
// Truncate file to size 0, similar to `O_TRUNC` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_OPEN_FLAGS_TRUNCATE (1 << 3)

// Permissions mode used by `open-at`, `change-file-permissions-at`, and
// similar.
typedef uint8_t wasi_filesystem_0_2_0_rc_2023_10_18_types_modes_t;

// True if the resource is considered readable by the containing
// filesystem.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_MODES_READABLE (1 << 0)
// True if the resource is considered writable by the containing
// filesystem.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_MODES_WRITABLE (1 << 1)
// True if the resource is considered executable by the containing
// filesystem. This does not apply to directories.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_MODES_EXECUTABLE (1 << 2)

// Access type used by `access-at`.
typedef struct {
  uint8_t tag;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_modes_t access;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_access_type_t;

// Test for readability, writeability, or executability.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ACCESS_TYPE_ACCESS 0
// Test whether the path exists.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ACCESS_TYPE_EXISTS 1

// Number of hard links to an inode.
typedef uint64_t wasi_filesystem_0_2_0_rc_2023_10_18_types_link_count_t;

typedef struct {
  bool is_some;
  wasi_filesystem_0_2_0_rc_2023_10_18_types_datetime_t val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_option_datetime_t;

// File attributes.
// 
// Note: This was called `filestat` in earlier versions of WASI.
typedef struct {
  // File type.
  wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_type_t type;
  // Number of hard links to the file.
  wasi_filesystem_0_2_0_rc_2023_10_18_types_link_count_t link_count;
  // For regular files, the file size in bytes. For symbolic links, the
  // length in bytes of the pathname contained in the symbolic link.
  wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t size;
  // Last data access timestamp.
  // 
  // If the `option` is none, the platform doesn't maintain an access
  // timestamp for this file.
  wasi_filesystem_0_2_0_rc_2023_10_18_types_option_datetime_t data_access_timestamp;
  // Last data modification timestamp.
  // 
  // If the `option` is none, the platform doesn't maintain a
  // modification timestamp for this file.
  wasi_filesystem_0_2_0_rc_2023_10_18_types_option_datetime_t data_modification_timestamp;
  // Last file status-change timestamp.
  // 
  // If the `option` is none, the platform doesn't maintain a
  // status-change timestamp for this file.
  wasi_filesystem_0_2_0_rc_2023_10_18_types_option_datetime_t status_change_timestamp;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_stat_t;

// When setting a timestamp, this gives the value to set it to.
typedef struct {
  uint8_t tag;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_datetime_t timestamp;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_new_timestamp_t;

// Leave the timestamp set to its previous value.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_NEW_TIMESTAMP_NO_CHANGE 0
// Set the timestamp to the current time of the system clock associated
// with the filesystem.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_NEW_TIMESTAMP_NOW 1
// Set the timestamp to the given value.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_NEW_TIMESTAMP_TIMESTAMP 2

// A directory entry.
typedef struct {
  // The type of the file referred to by this directory entry.
  wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_type_t type;
  // The name of the object.
  http_trigger_string_t name;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_directory_entry_t;

// Error codes returned by functions, similar to `errno` in POSIX.
// Not all of these error codes are returned by the functions provided by this
// API; some are used in higher-level library layers, and others are provided
// merely for alignment with POSIX.
typedef uint8_t wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t;

// Permission denied, similar to `EACCES` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_ACCESS 0
// Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_WOULD_BLOCK 1
// Connection already in progress, similar to `EALREADY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_ALREADY 2
// Bad descriptor, similar to `EBADF` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_BAD_DESCRIPTOR 3
// Device or resource busy, similar to `EBUSY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_BUSY 4
// Resource deadlock would occur, similar to `EDEADLK` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_DEADLOCK 5
// Storage quota exceeded, similar to `EDQUOT` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_QUOTA 6
// File exists, similar to `EEXIST` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_EXIST 7
// File too large, similar to `EFBIG` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_FILE_TOO_LARGE 8
// Illegal byte sequence, similar to `EILSEQ` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_ILLEGAL_BYTE_SEQUENCE 9
// Operation in progress, similar to `EINPROGRESS` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_IN_PROGRESS 10
// Interrupted function, similar to `EINTR` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_INTERRUPTED 11
// Invalid argument, similar to `EINVAL` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_INVALID 12
// I/O error, similar to `EIO` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_IO 13
// Is a directory, similar to `EISDIR` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_IS_DIRECTORY 14
// Too many levels of symbolic links, similar to `ELOOP` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_LOOP 15
// Too many links, similar to `EMLINK` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_TOO_MANY_LINKS 16
// Message too large, similar to `EMSGSIZE` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_MESSAGE_SIZE 17
// Filename too long, similar to `ENAMETOOLONG` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_NAME_TOO_LONG 18
// No such device, similar to `ENODEV` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_NO_DEVICE 19
// No such file or directory, similar to `ENOENT` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_NO_ENTRY 20
// No locks available, similar to `ENOLCK` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_NO_LOCK 21
// Not enough space, similar to `ENOMEM` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_INSUFFICIENT_MEMORY 22
// No space left on device, similar to `ENOSPC` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_INSUFFICIENT_SPACE 23
// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_NOT_DIRECTORY 24
// Directory not empty, similar to `ENOTEMPTY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_NOT_EMPTY 25
// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_NOT_RECOVERABLE 26
// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_UNSUPPORTED 27
// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_NO_TTY 28
// No such device or address, similar to `ENXIO` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_NO_SUCH_DEVICE 29
// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_OVERFLOW 30
// Operation not permitted, similar to `EPERM` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_NOT_PERMITTED 31
// Broken pipe, similar to `EPIPE` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_PIPE 32
// Read-only file system, similar to `EROFS` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_READ_ONLY 33
// Invalid seek, similar to `ESPIPE` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_INVALID_SEEK 34
// Text file busy, similar to `ETXTBSY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_TEXT_FILE_BUSY 35
// Cross-device link, similar to `EXDEV` in POSIX.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ERROR_CODE_CROSS_DEVICE 36

// File or memory access pattern advisory information.
typedef uint8_t wasi_filesystem_0_2_0_rc_2023_10_18_types_advice_t;

// The application has no advice to give on its behavior with respect
// to the specified data.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ADVICE_NORMAL 0
// The application expects to access the specified data sequentially
// from lower offsets to higher offsets.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ADVICE_SEQUENTIAL 1
// The application expects to access the specified data in a random
// order.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ADVICE_RANDOM 2
// The application expects to access the specified data in the near
// future.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ADVICE_WILL_NEED 3
// The application expects that it will not access the specified data
// in the near future.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ADVICE_DONT_NEED 4
// The application expects to access the specified data once and then
// not reuse it thereafter.
#define WASI_FILESYSTEM_0_2_0_RC_2023_10_18_TYPES_ADVICE_NO_REUSE 5

// A 128-bit hash value, split into parts because wasm doesn't have a
// 128-bit integer type.
typedef struct {
  // 64 bits of a 128-bit hash value.
  uint64_t lower;
  // Another 64 bits of a 128-bit hash value.
  uint64_t upper;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_metadata_hash_value_t;

typedef struct wasi_filesystem_0_2_0_rc_2023_10_18_types_own_descriptor_t {
  int32_t __handle;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_own_descriptor_t;

typedef struct wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t {
  int32_t __handle;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t;

typedef struct wasi_filesystem_0_2_0_rc_2023_10_18_types_own_directory_entry_stream_t {
  int32_t __handle;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_own_directory_entry_stream_t;

typedef struct wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_directory_entry_stream_t {
  int32_t __handle;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_directory_entry_stream_t;

typedef wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t wasi_filesystem_0_2_0_rc_2023_10_18_types_own_input_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_own_input_stream_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_input_stream_error_code_t;

typedef wasi_io_0_2_0_rc_2023_10_18_streams_own_output_stream_t wasi_filesystem_0_2_0_rc_2023_10_18_types_own_output_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_own_output_stream_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_output_stream_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_void_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_flags_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_descriptor_flags_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_type_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_descriptor_type_error_code_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_list_u8_t;

typedef struct {
  wasi_filesystem_0_2_0_rc_2023_10_18_types_list_u8_t f0;
  bool f1;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_tuple2_list_u8_bool_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_tuple2_list_u8_bool_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_tuple2_list_u8_bool_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_filesize_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_own_directory_entry_stream_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_directory_entry_stream_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_stat_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_descriptor_stat_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_own_descriptor_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_descriptor_error_code_t;

typedef struct {
  bool is_err;
  union {
    http_trigger_string_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_string_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_metadata_hash_value_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_metadata_hash_value_error_code_t;

typedef struct {
  bool is_some;
  wasi_filesystem_0_2_0_rc_2023_10_18_types_directory_entry_t val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_option_directory_entry_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_rc_2023_10_18_types_option_directory_entry_t ok;
    wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_result_option_directory_entry_error_code_t;

typedef wasi_io_0_2_0_rc_2023_10_18_streams_borrow_error_t wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_error_t;

typedef struct {
  bool is_some;
  wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t val;
} wasi_filesystem_0_2_0_rc_2023_10_18_types_option_error_code_t;

typedef wasi_filesystem_0_2_0_rc_2023_10_18_types_own_descriptor_t wasi_filesystem_0_2_0_rc_2023_10_18_preopens_own_descriptor_t;

typedef struct {
  wasi_filesystem_0_2_0_rc_2023_10_18_preopens_own_descriptor_t f0;
  http_trigger_string_t f1;
} wasi_filesystem_0_2_0_rc_2023_10_18_preopens_tuple2_own_descriptor_string_t;

typedef struct {
  wasi_filesystem_0_2_0_rc_2023_10_18_preopens_tuple2_own_descriptor_string_t *ptr;
  size_t len;
} wasi_filesystem_0_2_0_rc_2023_10_18_preopens_list_tuple2_own_descriptor_string_t;

typedef struct wasi_sockets_0_2_0_rc_2023_10_18_network_own_network_t {
  int32_t __handle;
} wasi_sockets_0_2_0_rc_2023_10_18_network_own_network_t;

typedef struct wasi_sockets_0_2_0_rc_2023_10_18_network_borrow_network_t {
  int32_t __handle;
} wasi_sockets_0_2_0_rc_2023_10_18_network_borrow_network_t;

// Error codes.
// 
// In theory, every API can return any error code.
// In practice, API's typically only return the errors documented per API
// combined with a couple of errors that are always possible:
// - `unknown`
// - `access-denied`
// - `not-supported`
// - `out-of-memory`
// - `concurrency-conflict`
// 
// See each individual API for what the POSIX equivalents are. They sometimes differ per API.
typedef uint8_t wasi_sockets_0_2_0_rc_2023_10_18_network_error_code_t;

// ### GENERAL ERRORS ###
// Unknown error
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_UNKNOWN 0
// Access denied.
// 
// POSIX equivalent: EACCES, EPERM
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_ACCESS_DENIED 1
// The operation is not supported.
// 
// POSIX equivalent: EOPNOTSUPP
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_NOT_SUPPORTED 2
// One of the arguments is invalid.
// 
// POSIX equivalent: EINVAL
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_INVALID_ARGUMENT 3
// Not enough memory to complete the operation.
// 
// POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_OUT_OF_MEMORY 4
// The operation timed out before it could finish completely.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_TIMEOUT 5
// This operation is incompatible with another asynchronous operation that is already in progress.
// 
// POSIX equivalent: EALREADY
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_CONCURRENCY_CONFLICT 6
// Trying to finish an asynchronous operation that:
// - has not been started yet, or:
// - was already finished by a previous `finish-*` call.
// 
// Note: this is scheduled to be removed when `future`s are natively supported.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_NOT_IN_PROGRESS 7
// The operation has been aborted because it could not be completed immediately.
// 
// Note: this is scheduled to be removed when `future`s are natively supported.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_WOULD_BLOCK 8
// ### TCP & UDP SOCKET ERRORS ###
// The operation is not valid in the socket's current state.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_INVALID_STATE 9
// A new socket resource could not be created because of a system limit.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_NEW_SOCKET_LIMIT 10
// A bind operation failed because the provided address is not an address that the `network` can bind to.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_ADDRESS_NOT_BINDABLE 11
// A bind operation failed because the provided address is already in use or because there are no ephemeral ports available.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_ADDRESS_IN_USE 12
// The remote address is not reachable
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_REMOTE_UNREACHABLE 13
// ### TCP SOCKET ERRORS ###
// The connection was forcefully rejected
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_CONNECTION_REFUSED 14
// The connection was reset.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_CONNECTION_RESET 15
// A connection was aborted.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_CONNECTION_ABORTED 16
// ### UDP SOCKET ERRORS ###
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_DATAGRAM_TOO_LARGE 17
// ### NAME LOOKUP ERRORS ###
// Name does not exist or has no suitable associated IP addresses.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_NAME_UNRESOLVABLE 18
// A temporary failure in name resolution occurred.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_TEMPORARY_RESOLVER_FAILURE 19
// A permanent failure in name resolution occurred.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_ERROR_CODE_PERMANENT_RESOLVER_FAILURE 20

typedef uint8_t wasi_sockets_0_2_0_rc_2023_10_18_network_ip_address_family_t;

// Similar to `AF_INET` in POSIX.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_IP_ADDRESS_FAMILY_IPV4 0
// Similar to `AF_INET6` in POSIX.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_IP_ADDRESS_FAMILY_IPV6 1

typedef struct {
  uint8_t f0;
  uint8_t f1;
  uint8_t f2;
  uint8_t f3;
} wasi_sockets_0_2_0_rc_2023_10_18_network_ipv4_address_t;

typedef struct {
  uint16_t f0;
  uint16_t f1;
  uint16_t f2;
  uint16_t f3;
  uint16_t f4;
  uint16_t f5;
  uint16_t f6;
  uint16_t f7;
} wasi_sockets_0_2_0_rc_2023_10_18_network_ipv6_address_t;

typedef struct {
  uint8_t tag;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_network_ipv4_address_t ipv4;
    wasi_sockets_0_2_0_rc_2023_10_18_network_ipv6_address_t ipv6;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_network_ip_address_t;

#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_IP_ADDRESS_IPV4 0
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_IP_ADDRESS_IPV6 1

typedef struct {
  uint16_t port;
  // sin_port
  wasi_sockets_0_2_0_rc_2023_10_18_network_ipv4_address_t address;
} wasi_sockets_0_2_0_rc_2023_10_18_network_ipv4_socket_address_t;

typedef struct {
  uint16_t port;
  // sin6_port
  uint32_t flow_info;
  // sin6_flowinfo
  wasi_sockets_0_2_0_rc_2023_10_18_network_ipv6_address_t address;
  // sin6_addr
  uint32_t scope_id;
} wasi_sockets_0_2_0_rc_2023_10_18_network_ipv6_socket_address_t;

typedef struct {
  uint8_t tag;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_network_ipv4_socket_address_t ipv4;
    wasi_sockets_0_2_0_rc_2023_10_18_network_ipv6_socket_address_t ipv6;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_network_ip_socket_address_t;

#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_IP_SOCKET_ADDRESS_IPV4 0
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_NETWORK_IP_SOCKET_ADDRESS_IPV6 1

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_own_network_t wasi_sockets_0_2_0_rc_2023_10_18_instance_network_own_network_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_error_code_t wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_error_code_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_ip_address_t wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_ip_address_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_ip_address_family_t wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_ip_address_family_t;

typedef struct wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_own_resolve_address_stream_t {
  int32_t __handle;
} wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_own_resolve_address_stream_t;

typedef struct wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_borrow_resolve_address_stream_t {
  int32_t __handle;
} wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_borrow_resolve_address_stream_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_borrow_network_t wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_borrow_network_t;

typedef struct {
  bool is_some;
  wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_ip_address_family_t val;
} wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_option_ip_address_family_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_own_resolve_address_stream_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_result_own_resolve_address_stream_error_code_t;

typedef struct {
  bool is_some;
  wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_ip_address_t val;
} wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_option_ip_address_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_option_ip_address_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_result_option_ip_address_error_code_t;

typedef wasi_io_0_2_0_rc_2023_10_18_poll_own_pollable_t wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_own_pollable_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_error_code_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_ip_socket_address_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_ip_socket_address_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_ip_address_family_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_ip_address_family_t;

typedef uint8_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_shutdown_type_t;

// Similar to `SHUT_RD` in POSIX.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_TCP_SHUTDOWN_TYPE_RECEIVE 0
// Similar to `SHUT_WR` in POSIX.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_TCP_SHUTDOWN_TYPE_SEND 1
// Similar to `SHUT_RDWR` in POSIX.
#define WASI_SOCKETS_0_2_0_RC_2023_10_18_TCP_SHUTDOWN_TYPE_BOTH 2

typedef struct wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_tcp_socket_t {
  int32_t __handle;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_tcp_socket_t;

typedef struct wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t {
  int32_t __handle;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_borrow_network_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_network_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_void_error_code_t;

typedef wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_input_stream_t;

typedef wasi_io_0_2_0_rc_2023_10_18_streams_own_output_stream_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_output_stream_t;

typedef struct {
  wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_input_stream_t f0;
  wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_output_stream_t f1;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_tuple2_own_input_stream_own_output_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_tuple2_own_input_stream_own_output_stream_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_tuple2_own_input_stream_own_output_stream_error_code_t;

typedef struct {
  wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_tcp_socket_t f0;
  wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_input_stream_t f1;
  wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_output_stream_t f2;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_tuple3_own_tcp_socket_own_input_stream_own_output_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_tuple3_own_tcp_socket_own_input_stream_own_output_stream_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_tuple3_own_tcp_socket_own_input_stream_own_output_stream_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_ip_socket_address_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_ip_socket_address_error_code_t;

typedef struct {
  bool is_err;
  union {
    bool ok;
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_bool_error_code_t;

typedef struct {
  bool is_err;
  union {
    uint8_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_u8_error_code_t;

typedef struct {
  bool is_err;
  union {
    uint64_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_u64_error_code_t;

typedef wasi_io_0_2_0_rc_2023_10_18_poll_own_pollable_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_pollable_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_error_code_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_error_code_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_ip_address_family_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_ip_address_family_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_tcp_socket_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_own_tcp_socket_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_own_tcp_socket_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_result_own_tcp_socket_error_code_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_error_code_t wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_ip_socket_address_t wasi_sockets_0_2_0_rc_2023_10_18_udp_ip_socket_address_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_ip_address_family_t wasi_sockets_0_2_0_rc_2023_10_18_udp_ip_address_family_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_list_u8_t;

typedef struct {
  wasi_sockets_0_2_0_rc_2023_10_18_udp_list_u8_t data;
  // Theoretical max size: ~64 KiB. In practice, typically less than 1500 bytes.
  wasi_sockets_0_2_0_rc_2023_10_18_udp_ip_socket_address_t remote_address;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_datagram_t;

typedef struct wasi_sockets_0_2_0_rc_2023_10_18_udp_own_udp_socket_t {
  int32_t __handle;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_own_udp_socket_t;

typedef struct wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t {
  int32_t __handle;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_borrow_network_t wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_network_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_result_void_error_code_t;

typedef struct {
  wasi_sockets_0_2_0_rc_2023_10_18_udp_datagram_t *ptr;
  size_t len;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_list_datagram_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_udp_list_datagram_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_result_list_datagram_error_code_t;

typedef struct {
  bool is_err;
  union {
    uint64_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_result_u64_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_udp_ip_socket_address_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_result_ip_socket_address_error_code_t;

typedef struct {
  bool is_err;
  union {
    bool ok;
    wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_result_bool_error_code_t;

typedef struct {
  bool is_err;
  union {
    uint8_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_result_u8_error_code_t;

typedef wasi_io_0_2_0_rc_2023_10_18_poll_own_pollable_t wasi_sockets_0_2_0_rc_2023_10_18_udp_own_pollable_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_error_code_t wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_error_code_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_network_ip_address_family_t wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_ip_address_family_t;

typedef wasi_sockets_0_2_0_rc_2023_10_18_udp_own_udp_socket_t wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_own_udp_socket_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_own_udp_socket_t ok;
    wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_error_code_t err;
  } val;
} wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_result_own_udp_socket_error_code_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} wasi_random_0_2_0_rc_2023_10_18_random_list_u8_t;

typedef struct {
  uint64_t f0;
  uint64_t f1;
} wasi_random_0_2_0_rc_2023_10_18_insecure_seed_tuple2_u64_u64_t;

typedef struct {
  http_trigger_string_t f0;
  http_trigger_string_t f1;
} wasi_cli_0_2_0_rc_2023_10_18_environment_tuple2_string_string_t;

typedef struct {
  wasi_cli_0_2_0_rc_2023_10_18_environment_tuple2_string_string_t *ptr;
  size_t len;
} wasi_cli_0_2_0_rc_2023_10_18_environment_list_tuple2_string_string_t;

typedef struct {
  http_trigger_string_t *ptr;
  size_t len;
} wasi_cli_0_2_0_rc_2023_10_18_environment_list_string_t;

typedef struct {
  bool is_some;
  http_trigger_string_t val;
} wasi_cli_0_2_0_rc_2023_10_18_environment_option_string_t;

typedef struct {
  bool is_err;
} wasi_cli_0_2_0_rc_2023_10_18_exit_result_void_void_t;

typedef wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t wasi_cli_0_2_0_rc_2023_10_18_stdin_own_input_stream_t;

typedef wasi_io_0_2_0_rc_2023_10_18_streams_own_output_stream_t wasi_cli_0_2_0_rc_2023_10_18_stdout_own_output_stream_t;

typedef wasi_io_0_2_0_rc_2023_10_18_streams_own_output_stream_t wasi_cli_0_2_0_rc_2023_10_18_stderr_own_output_stream_t;

typedef struct wasi_cli_0_2_0_rc_2023_10_18_terminal_input_own_terminal_input_t {
  int32_t __handle;
} wasi_cli_0_2_0_rc_2023_10_18_terminal_input_own_terminal_input_t;

typedef struct wasi_cli_0_2_0_rc_2023_10_18_terminal_input_borrow_terminal_input_t {
  int32_t __handle;
} wasi_cli_0_2_0_rc_2023_10_18_terminal_input_borrow_terminal_input_t;

typedef struct wasi_cli_0_2_0_rc_2023_10_18_terminal_output_own_terminal_output_t {
  int32_t __handle;
} wasi_cli_0_2_0_rc_2023_10_18_terminal_output_own_terminal_output_t;

typedef struct wasi_cli_0_2_0_rc_2023_10_18_terminal_output_borrow_terminal_output_t {
  int32_t __handle;
} wasi_cli_0_2_0_rc_2023_10_18_terminal_output_borrow_terminal_output_t;

typedef wasi_cli_0_2_0_rc_2023_10_18_terminal_input_own_terminal_input_t wasi_cli_0_2_0_rc_2023_10_18_terminal_stdin_own_terminal_input_t;

typedef struct {
  bool is_some;
  wasi_cli_0_2_0_rc_2023_10_18_terminal_stdin_own_terminal_input_t val;
} wasi_cli_0_2_0_rc_2023_10_18_terminal_stdin_option_own_terminal_input_t;

typedef wasi_cli_0_2_0_rc_2023_10_18_terminal_output_own_terminal_output_t wasi_cli_0_2_0_rc_2023_10_18_terminal_stdout_own_terminal_output_t;

typedef struct {
  bool is_some;
  wasi_cli_0_2_0_rc_2023_10_18_terminal_stdout_own_terminal_output_t val;
} wasi_cli_0_2_0_rc_2023_10_18_terminal_stdout_option_own_terminal_output_t;

typedef wasi_cli_0_2_0_rc_2023_10_18_terminal_output_own_terminal_output_t wasi_cli_0_2_0_rc_2023_10_18_terminal_stderr_own_terminal_output_t;

typedef struct {
  bool is_some;
  wasi_cli_0_2_0_rc_2023_10_18_terminal_stderr_own_terminal_output_t val;
} wasi_cli_0_2_0_rc_2023_10_18_terminal_stderr_option_own_terminal_output_t;

typedef wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_request_t exports_wasi_http_0_2_0_rc_2023_10_18_incoming_handler_own_incoming_request_t;

typedef wasi_http_0_2_0_rc_2023_10_18_types_own_response_outparam_t exports_wasi_http_0_2_0_rc_2023_10_18_incoming_handler_own_response_outparam_t;

// Imported Functions from `wasi:io/poll@0.2.0-rc-2023-10-18`
// Poll for completion on a set of pollables.
// 
// This function takes a list of pollables, which identify I/O sources of
// interest, and waits until one or more of the events is ready for I/O.
// 
// The result `list<u32>` contains one or more indices of handles in the
// argument list that is ready for I/O.
// 
// If the list contains more elements than can be indexed with a `u32`
// value, this function traps.
// 
// A timeout can be implemented by adding a pollable from the
// wasi-clocks API to the list.
// 
// This function does not return a `result`; polling in itself does not
// do any I/O so it doesn't fail. If any of the I/O sources identified by
// the pollables has an error, it is indicated by marking the source as
// being reaedy for I/O.
extern void wasi_io_0_2_0_rc_2023_10_18_poll_poll_list(wasi_io_0_2_0_rc_2023_10_18_poll_list_borrow_pollable_t *in, wasi_io_0_2_0_rc_2023_10_18_poll_list_u32_t *ret);
// Poll for completion on a single pollable.
// 
// This function is similar to `poll-list`, but operates on only a single
// pollable. When it returns, the handle is ready for I/O.
extern void wasi_io_0_2_0_rc_2023_10_18_poll_poll_one(wasi_io_0_2_0_rc_2023_10_18_poll_borrow_pollable_t in);

// Imported Functions from `wasi:io/streams@0.2.0-rc-2023-10-18`
// Returns a string that's suitable to assist humans in debugging this
// error.
// 
// The returned string will change across platforms and hosts which
// means that parsing it, for example, would be a
// platform-compatibility hazard.
extern void wasi_io_0_2_0_rc_2023_10_18_streams_method_error_to_debug_string(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_error_t self, http_trigger_string_t *ret);
// Perform a non-blocking read from the stream.
// 
// This function returns a list of bytes containing the data that was
// read, along with a `stream-status` which, indicates whether further
// reads are expected to produce data. The returned list will contain up to
// `len` bytes; it may return fewer than requested, but not more. An
// empty list and `stream-status:open` indicates no more data is
// available at this time, and that the pollable given by `subscribe`
// will be ready when more data is available.
// 
// Once a stream has reached the end, subsequent calls to `read` or
// `skip` will always report `stream-status:ended` rather than producing more
// data.
// 
// When the caller gives a `len` of 0, it represents a request to read 0
// bytes. This read should  always succeed and return an empty list and
// the current `stream-status`.
// 
// The `len` parameter is a `u64`, which could represent a list of u8 which
// is not possible to allocate in wasm32, or not desirable to allocate as
// as a return value by the callee. The callee may return a list of bytes
// less than `len` in size while more bytes are available for reading.
extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_input_stream_read(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_input_stream_t self, uint64_t len, wasi_io_0_2_0_rc_2023_10_18_streams_list_u8_t *ret, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
// Read bytes from a stream, after blocking until at least one byte can
// be read. Except for blocking, identical to `read`.
extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_input_stream_blocking_read(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_input_stream_t self, uint64_t len, wasi_io_0_2_0_rc_2023_10_18_streams_list_u8_t *ret, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
// Skip bytes from a stream.
// 
// This is similar to the `read` function, but avoids copying the
// bytes into the instance.
// 
// Once a stream has reached the end, subsequent calls to read or
// `skip` will always report end-of-stream rather than producing more
// data.
// 
// This function returns the number of bytes skipped, along with a
// `stream-status` indicating whether the end of the stream was
// reached. The returned value will be at most `len`; it may be less.
extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_input_stream_skip(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_input_stream_t self, uint64_t len, uint64_t *ret, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
// Skip bytes from a stream, after blocking until at least one byte
// can be skipped. Except for blocking behavior, identical to `skip`.
extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_input_stream_blocking_skip(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_input_stream_t self, uint64_t len, uint64_t *ret, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
// Create a `pollable` which will resolve once either the specified stream
// has bytes available to read or the other end of the stream has been
// closed.
// The created `pollable` is a child resource of the `input-stream`.
// Implementations may trap if the `input-stream` is dropped before
// all derived `pollable`s created with this function are dropped.
extern wasi_io_0_2_0_rc_2023_10_18_streams_own_pollable_t wasi_io_0_2_0_rc_2023_10_18_streams_method_input_stream_subscribe(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_input_stream_t self);
// Check readiness for writing. This function never blocks.
// 
// Returns the number of bytes permitted for the next call to `write`,
// or an error. Calling `write` with more bytes than this function has
// permitted will trap.
// 
// When this function returns 0 bytes, the `subscribe` pollable will
// become ready when this function will report at least 1 byte, or an
// error.
extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_output_stream_check_write(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t self, uint64_t *ret, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
// Perform a write. This function never blocks.
// 
// Precondition: check-write gave permit of Ok(n) and contents has a
// length of less than or equal to n. Otherwise, this function will trap.
// 
// returns Err(closed) without writing if the stream has closed since
// the last call to check-write provided a permit.
extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_output_stream_write(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t self, wasi_io_0_2_0_rc_2023_10_18_streams_list_u8_t *contents, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
// Perform a write of up to 4096 bytes, and then flush the stream. Block
// until all of these operations are complete, or an error occurs.
// 
// This is a convenience wrapper around the use of `check-write`,
// `subscribe`, `write`, and `flush`, and is implemented with the
// following pseudo-code:
// 
// ```text
// let pollable = this.subscribe();
// while !contents.is_empty() {
  // // Wait for the stream to become writable
  // poll-one(pollable);
  // let Ok(n) = this.check-write(); // eliding error handling
  // let len = min(n, contents.len());
  // let (chunk, rest) = contents.split_at(len);
  // this.write(chunk  );            // eliding error handling
  // contents = rest;
  // }
  // this.flush();
  // // Wait for completion of `flush`
  // poll-one(pollable);
  // // Check for any errors that arose during `flush`
  // let _ = this.check-write();         // eliding error handling
  // ```
  extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_output_stream_blocking_write_and_flush(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t self, wasi_io_0_2_0_rc_2023_10_18_streams_list_u8_t *contents, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
  // Request to flush buffered output. This function never blocks.
  // 
  // This tells the output-stream that the caller intends any buffered
  // output to be flushed. the output which is expected to be flushed
  // is all that has been passed to `write` prior to this call.
  // 
  // Upon calling this function, the `output-stream` will not accept any
  // writes (`check-write` will return `ok(0)`) until the flush has
  // completed. The `subscribe` pollable will become ready when the
  // flush has completed and the stream can accept more writes.
  extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_output_stream_flush(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t self, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
  // Request to flush buffered output, and block until flush completes
  // and stream is ready for writing again.
  extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_output_stream_blocking_flush(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t self, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
  // Create a `pollable` which will resolve once the output-stream
  // is ready for more writing, or an error has occured. When this
  // pollable is ready, `check-write` will return `ok(n)` with n>0, or an
  // error.
  // 
  // If the stream is closed, this pollable is always ready immediately.
  // 
  // The created `pollable` is a child resource of the `output-stream`.
  // Implementations may trap if the `output-stream` is dropped before
  // all derived `pollable`s created with this function are dropped.
  extern wasi_io_0_2_0_rc_2023_10_18_streams_own_pollable_t wasi_io_0_2_0_rc_2023_10_18_streams_method_output_stream_subscribe(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t self);
  // Write zeroes to a stream.
  // 
  // this should be used precisely like `write` with the exact same
  // preconditions (must use check-write first), but instead of
  // passing a list of bytes, you simply pass the number of zero-bytes
  // that should be written.
  extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_output_stream_write_zeroes(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t self, uint64_t len, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
  // Perform a write of up to 4096 zeroes, and then flush the stream.
  // Block until all of these operations are complete, or an error
  // occurs.
  // 
  // This is a convenience wrapper around the use of `check-write`,
  // `subscribe`, `write-zeroes`, and `flush`, and is implemented with
  // the following pseudo-code:
  // 
  // ```text
  // let pollable = this.subscribe();
  // while num_zeroes != 0 {
    // // Wait for the stream to become writable
    // poll-one(pollable);
    // let Ok(n) = this.check-write(); // eliding error handling
    // let len = min(n, num_zeroes);
    // this.write-zeroes(len);         // eliding error handling
    // num_zeroes -= len;
    // }
    // this.flush();
    // // Wait for completion of `flush`
    // poll-one(pollable);
    // // Check for any errors that arose during `flush`
    // let _ = this.check-write();         // eliding error handling
    // ```
    extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_output_stream_blocking_write_zeroes_and_flush(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t self, uint64_t len, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
    // Read from one stream and write to another.
    // 
    // This function returns the number of bytes transferred; it may be less
    // than `len`.
    // 
    // Unlike other I/O functions, this function blocks until all the data
    // read from the input stream has been written to the output stream.
    extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_output_stream_splice(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t self, wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t src, uint64_t len, uint64_t *ret, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
    // Read from one stream and write to another, with blocking.
    // 
    // This is similar to `splice`, except that it blocks until at least
    // one byte can be read.
    extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_output_stream_blocking_splice(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t self, wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t src, uint64_t len, uint64_t *ret, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
    // Forward the entire contents of an input stream to an output stream.
    // 
    // This function repeatedly reads from the input stream and writes
    // the data to the output stream, until the end of the input stream
    // is reached, or an error is encountered.
    // 
    // Unlike other I/O functions, this function blocks until the end
    // of the input stream is seen and all the data has been written to
    // the output stream.
    // 
    // This function returns the number of bytes transferred, and the status of
    // the output stream.
    extern bool wasi_io_0_2_0_rc_2023_10_18_streams_method_output_stream_forward(wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t self, wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t src, uint64_t *ret, wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *err);
    
    // Imported Functions from `wasi:http/types@0.2.0-rc-2023-10-18`
    // Multiple values for a header are multiple entries in the list with the
    // same key.
    extern wasi_http_0_2_0_rc_2023_10_18_types_own_fields_t wasi_http_0_2_0_rc_2023_10_18_types_constructor_fields(wasi_http_0_2_0_rc_2023_10_18_types_list_tuple2_string_list_u8_t *entries);
    // Values off wire are not necessarily well formed, so they are given by
    // list<u8> instead of string.
    extern void wasi_http_0_2_0_rc_2023_10_18_types_method_fields_get(wasi_http_0_2_0_rc_2023_10_18_types_borrow_fields_t self, http_trigger_string_t *name, wasi_http_0_2_0_rc_2023_10_18_types_list_list_u8_t *ret);
    // Values off wire are not necessarily well formed, so they are given by
    // list<u8> instead of string.
    extern void wasi_http_0_2_0_rc_2023_10_18_types_method_fields_set(wasi_http_0_2_0_rc_2023_10_18_types_borrow_fields_t self, http_trigger_string_t *name, wasi_http_0_2_0_rc_2023_10_18_types_list_list_u8_t *value);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_method_fields_delete(wasi_http_0_2_0_rc_2023_10_18_types_borrow_fields_t self, http_trigger_string_t *name);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_method_fields_append(wasi_http_0_2_0_rc_2023_10_18_types_borrow_fields_t self, http_trigger_string_t *name, wasi_http_0_2_0_rc_2023_10_18_types_list_u8_t *value);
    // Values off wire are not necessarily well formed, so they are given by
    // list<u8> instead of string.
    extern void wasi_http_0_2_0_rc_2023_10_18_types_method_fields_entries(wasi_http_0_2_0_rc_2023_10_18_types_borrow_fields_t self, wasi_http_0_2_0_rc_2023_10_18_types_list_tuple2_string_list_u8_t *ret);
    // Deep copy of all contents in a fields.
    extern wasi_http_0_2_0_rc_2023_10_18_types_own_fields_t wasi_http_0_2_0_rc_2023_10_18_types_method_fields_clone(wasi_http_0_2_0_rc_2023_10_18_types_borrow_fields_t self);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_method_incoming_request_method(wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_request_t self, wasi_http_0_2_0_rc_2023_10_18_types_method_t *ret);
    extern bool wasi_http_0_2_0_rc_2023_10_18_types_method_incoming_request_path_with_query(wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_request_t self, http_trigger_string_t *ret);
    extern bool wasi_http_0_2_0_rc_2023_10_18_types_method_incoming_request_scheme(wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_request_t self, wasi_http_0_2_0_rc_2023_10_18_types_scheme_t *ret);
    extern bool wasi_http_0_2_0_rc_2023_10_18_types_method_incoming_request_authority(wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_request_t self, http_trigger_string_t *ret);
    extern wasi_http_0_2_0_rc_2023_10_18_types_own_headers_t wasi_http_0_2_0_rc_2023_10_18_types_method_incoming_request_headers(wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_request_t self);
    // Returns the input-stream child at most once.
    // 
    // If called more than once, subsequent calls return an error.
    extern bool wasi_http_0_2_0_rc_2023_10_18_types_method_incoming_request_consume(wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_request_t self, wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_body_t *ret);
    extern wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_request_t wasi_http_0_2_0_rc_2023_10_18_types_constructor_outgoing_request(wasi_http_0_2_0_rc_2023_10_18_types_method_t *method, http_trigger_string_t *maybe_path_with_query, wasi_http_0_2_0_rc_2023_10_18_types_scheme_t *maybe_scheme, http_trigger_string_t *maybe_authority, wasi_http_0_2_0_rc_2023_10_18_types_borrow_headers_t headers);
    // Will return the outgoing-body child at most once.
    // 
    // If called more than once, subsequent calls return an error.
    extern bool wasi_http_0_2_0_rc_2023_10_18_types_method_outgoing_request_write(wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_request_t self, wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_body_t *ret);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_static_response_outparam_set(wasi_http_0_2_0_rc_2023_10_18_types_own_response_outparam_t param, wasi_http_0_2_0_rc_2023_10_18_types_result_own_outgoing_response_error_t *response);
    extern wasi_http_0_2_0_rc_2023_10_18_types_status_code_t wasi_http_0_2_0_rc_2023_10_18_types_method_incoming_response_status(wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_response_t self);
    extern wasi_http_0_2_0_rc_2023_10_18_types_own_headers_t wasi_http_0_2_0_rc_2023_10_18_types_method_incoming_response_headers(wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_response_t self);
    // May be called at most once. returns error if called additional times.
    // TODO: make incoming-request-consume work the same way, giving a child
    // incoming-body.
    extern bool wasi_http_0_2_0_rc_2023_10_18_types_method_incoming_response_consume(wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_response_t self, wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_body_t *ret);
    // returned input-stream is a child - the implementation may trap if
    // incoming-body is dropped (or consumed by call to
    // incoming-body-finish) before the input-stream is dropped.
    // May be called at most once. returns error if called additional times.
    extern bool wasi_http_0_2_0_rc_2023_10_18_types_method_incoming_body_stream(wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_body_t self, wasi_http_0_2_0_rc_2023_10_18_types_own_input_stream_t *ret);
    // takes ownership of incoming-body. this will trap if the
    // incoming-body-stream child is still alive!
    extern wasi_http_0_2_0_rc_2023_10_18_types_own_future_trailers_t wasi_http_0_2_0_rc_2023_10_18_types_static_incoming_body_finish(wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_body_t this_);
    // Pollable that resolves when the body has been fully read, and the trailers
    // are ready to be consumed.
    extern wasi_http_0_2_0_rc_2023_10_18_types_own_pollable_t wasi_http_0_2_0_rc_2023_10_18_types_method_future_trailers_subscribe(wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_trailers_t self);
    // Retrieve reference to trailers, if they are ready.
    extern bool wasi_http_0_2_0_rc_2023_10_18_types_method_future_trailers_get(wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_trailers_t self, wasi_http_0_2_0_rc_2023_10_18_types_result_own_trailers_error_t *ret);
    extern wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_response_t wasi_http_0_2_0_rc_2023_10_18_types_constructor_outgoing_response(wasi_http_0_2_0_rc_2023_10_18_types_status_code_t status_code, wasi_http_0_2_0_rc_2023_10_18_types_borrow_headers_t headers);
    // Will give the child outgoing-response at most once. subsequent calls will
    // return an error.
    extern bool wasi_http_0_2_0_rc_2023_10_18_types_method_outgoing_response_write(wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_response_t self, wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_body_t *ret);
    // Will give the child output-stream at most once. subsequent calls will
    // return an error.
    extern bool wasi_http_0_2_0_rc_2023_10_18_types_method_outgoing_body_write(wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_body_t self, wasi_http_0_2_0_rc_2023_10_18_types_own_output_stream_t *ret);
    // Finalize an outgoing body, optionally providing trailers. This must be
    // called to signal that the response is complete. If the `outgoing-body` is
    // dropped without calling `outgoing-body-finalize`, the implementation
    // should treat the body as corrupted.
    extern void wasi_http_0_2_0_rc_2023_10_18_types_static_outgoing_body_finish(wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_body_t this_, wasi_http_0_2_0_rc_2023_10_18_types_own_trailers_t *maybe_trailers);
    // option indicates readiness.
    // outer result indicates you are allowed to get the
    // incoming-response-or-error at most once. subsequent calls after ready
    // will return an error here.
    // inner result indicates whether the incoming-response was available, or an
    // error occured.
    extern bool wasi_http_0_2_0_rc_2023_10_18_types_method_future_incoming_response_get(wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_incoming_response_t self, wasi_http_0_2_0_rc_2023_10_18_types_result_result_own_incoming_response_error_void_t *ret);
    extern wasi_http_0_2_0_rc_2023_10_18_types_own_pollable_t wasi_http_0_2_0_rc_2023_10_18_types_method_future_incoming_response_subscribe(wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_incoming_response_t self);
    
    // Imported Functions from `wasi:http/outgoing-handler@0.2.0-rc-2023-10-18`
    // The parameter and result types of the `handle` function allow the caller
    // to concurrently stream the bodies of the outgoing request and the incoming
    // response.
    // Consumes the outgoing-request. Gives an error if the outgoing-request
    // is invalid or cannot be satisfied by this handler.
    extern bool wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_handle(wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_own_outgoing_request_t request, wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_request_options_t *maybe_options, wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_own_future_incoming_response_t *ret, wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_error_t *err);
    
    // Imported Functions from `fermyon:spin/llm@2.0.0`
    // Perform inferencing using the provided model and prompt with the given optional params
    extern bool fermyon_spin_2_0_0_llm_infer(fermyon_spin_2_0_0_llm_inferencing_model_t *model, http_trigger_string_t *prompt, fermyon_spin_2_0_0_llm_inferencing_params_t *maybe_params, fermyon_spin_2_0_0_llm_inferencing_result_t *ret, fermyon_spin_2_0_0_llm_error_t *err);
    // Generate embeddings for the supplied list of text
    extern bool fermyon_spin_2_0_0_llm_generate_embeddings(fermyon_spin_2_0_0_llm_embedding_model_t *model, fermyon_spin_2_0_0_llm_list_string_t *text, fermyon_spin_2_0_0_llm_embeddings_result_t *ret, fermyon_spin_2_0_0_llm_error_t *err);
    
    // Imported Functions from `fermyon:spin/redis@2.0.0`
    // Open a connection to the Redis instance at `address`.
    extern bool fermyon_spin_2_0_0_redis_static_connection_open(http_trigger_string_t *address, fermyon_spin_2_0_0_redis_own_connection_t *ret, fermyon_spin_2_0_0_redis_error_t *err);
    // Publish a Redis message to the specified channel.
    extern bool fermyon_spin_2_0_0_redis_method_connection_publish(fermyon_spin_2_0_0_redis_borrow_connection_t self, http_trigger_string_t *channel, fermyon_spin_2_0_0_redis_payload_t *payload, fermyon_spin_2_0_0_redis_error_t *err);
    // Get the value of a key.
    extern bool fermyon_spin_2_0_0_redis_method_connection_get(fermyon_spin_2_0_0_redis_borrow_connection_t self, http_trigger_string_t *key, fermyon_spin_2_0_0_redis_option_payload_t *ret, fermyon_spin_2_0_0_redis_error_t *err);
    // Set key to value.
    // 
    // If key already holds a value, it is overwritten.
    extern bool fermyon_spin_2_0_0_redis_method_connection_set(fermyon_spin_2_0_0_redis_borrow_connection_t self, http_trigger_string_t *key, fermyon_spin_2_0_0_redis_payload_t *value, fermyon_spin_2_0_0_redis_error_t *err);
    // Increments the number stored at key by one.
    // 
    // If the key does not exist, it is set to 0 before performing the operation.
    // An `error::type-error` is returned if the key contains a value of the wrong type
    // or contains a string that can not be represented as integer.
    extern bool fermyon_spin_2_0_0_redis_method_connection_incr(fermyon_spin_2_0_0_redis_borrow_connection_t self, http_trigger_string_t *key, int64_t *ret, fermyon_spin_2_0_0_redis_error_t *err);
    // Removes the specified keys.
    // 
    // A key is ignored if it does not exist. Returns the number of keys deleted.
    extern bool fermyon_spin_2_0_0_redis_method_connection_del(fermyon_spin_2_0_0_redis_borrow_connection_t self, fermyon_spin_2_0_0_llm_list_string_t *keys, uint32_t *ret, fermyon_spin_2_0_0_redis_error_t *err);
    // Add the specified `values` to the set named `key`, returning the number of newly-added values.
    extern bool fermyon_spin_2_0_0_redis_method_connection_sadd(fermyon_spin_2_0_0_redis_borrow_connection_t self, http_trigger_string_t *key, fermyon_spin_2_0_0_llm_list_string_t *values, uint32_t *ret, fermyon_spin_2_0_0_redis_error_t *err);
    // Retrieve the contents of the set named `key`.
    extern bool fermyon_spin_2_0_0_redis_method_connection_smembers(fermyon_spin_2_0_0_redis_borrow_connection_t self, http_trigger_string_t *key, fermyon_spin_2_0_0_llm_list_string_t *ret, fermyon_spin_2_0_0_redis_error_t *err);
    // Remove the specified `values` from the set named `key`, returning the number of newly-removed values.
    extern bool fermyon_spin_2_0_0_redis_method_connection_srem(fermyon_spin_2_0_0_redis_borrow_connection_t self, http_trigger_string_t *key, fermyon_spin_2_0_0_llm_list_string_t *values, uint32_t *ret, fermyon_spin_2_0_0_redis_error_t *err);
    // Execute an arbitrary Redis command and receive the result.
    extern bool fermyon_spin_2_0_0_redis_method_connection_execute(fermyon_spin_2_0_0_redis_borrow_connection_t self, http_trigger_string_t *command, fermyon_spin_2_0_0_redis_list_redis_parameter_t *arguments, fermyon_spin_2_0_0_redis_list_redis_result_t *ret, fermyon_spin_2_0_0_redis_error_t *err);
    
    // Imported Functions from `fermyon:spin/postgres@2.0.0`
    // Open a connection to the Postgres instance at `address`.
    extern bool fermyon_spin_2_0_0_postgres_static_connection_open(http_trigger_string_t *address, fermyon_spin_2_0_0_postgres_own_connection_t *ret, fermyon_spin_2_0_0_postgres_error_t *err);
    // Query the database.
    extern bool fermyon_spin_2_0_0_postgres_method_connection_query(fermyon_spin_2_0_0_postgres_borrow_connection_t self, http_trigger_string_t *statement, fermyon_spin_2_0_0_postgres_list_parameter_value_t *params, fermyon_spin_2_0_0_postgres_row_set_t *ret, fermyon_spin_2_0_0_postgres_error_t *err);
    // Execute command to the database.
    extern bool fermyon_spin_2_0_0_postgres_method_connection_execute(fermyon_spin_2_0_0_postgres_borrow_connection_t self, http_trigger_string_t *statement, fermyon_spin_2_0_0_postgres_list_parameter_value_t *params, uint64_t *ret, fermyon_spin_2_0_0_postgres_error_t *err);
    
    // Imported Functions from `fermyon:spin/mysql@2.0.0`
    // Open a connection to the MySQL instance at `address`.
    extern bool fermyon_spin_2_0_0_mysql_static_connection_open(http_trigger_string_t *address, fermyon_spin_2_0_0_mysql_own_connection_t *ret, fermyon_spin_2_0_0_mysql_error_t *err);
    // query the database: select
    extern bool fermyon_spin_2_0_0_mysql_method_connection_query(fermyon_spin_2_0_0_mysql_borrow_connection_t self, http_trigger_string_t *statement, fermyon_spin_2_0_0_mysql_list_parameter_value_t *params, fermyon_spin_2_0_0_mysql_row_set_t *ret, fermyon_spin_2_0_0_mysql_error_t *err);
    // execute command to the database: insert, update, delete
    extern bool fermyon_spin_2_0_0_mysql_method_connection_execute(fermyon_spin_2_0_0_mysql_borrow_connection_t self, http_trigger_string_t *statement, fermyon_spin_2_0_0_mysql_list_parameter_value_t *params, fermyon_spin_2_0_0_mysql_error_t *err);
    
    // Imported Functions from `fermyon:spin/sqlite@2.0.0`
    // Open a connection to a named database instance.
    // 
    // If `database` is "default", the default instance is opened.
    // 
    // `error::no-such-database` will be raised if the `name` is not recognized.
    extern bool fermyon_spin_2_0_0_sqlite_static_connection_open(http_trigger_string_t *database, fermyon_spin_2_0_0_sqlite_own_connection_t *ret, fermyon_spin_2_0_0_sqlite_error_t *err);
    // Execute a statement returning back data if there is any
    extern bool fermyon_spin_2_0_0_sqlite_method_connection_execute(fermyon_spin_2_0_0_sqlite_borrow_connection_t self, http_trigger_string_t *statement, fermyon_spin_2_0_0_sqlite_list_value_t *parameters, fermyon_spin_2_0_0_sqlite_query_result_t *ret, fermyon_spin_2_0_0_sqlite_error_t *err);
    
    // Imported Functions from `fermyon:spin/key-value@2.0.0`
    // Open the store with the specified label.
    // 
    // `label` must refer to a store allowed in the spin.toml manifest.
    // 
    // `error::no-such-store` will be raised if the `label` is not recognized.
    extern bool fermyon_spin_2_0_0_key_value_static_store_open(http_trigger_string_t *label, fermyon_spin_2_0_0_key_value_own_store_t *ret, fermyon_spin_2_0_0_key_value_error_t *err);
    // Get the value associated with the specified `key`
    // 
    // Returns `ok(none)` if the key does not exist.
    extern bool fermyon_spin_2_0_0_key_value_method_store_get(fermyon_spin_2_0_0_key_value_borrow_store_t self, http_trigger_string_t *key, fermyon_spin_2_0_0_key_value_option_list_u8_t *ret, fermyon_spin_2_0_0_key_value_error_t *err);
    // Set the `value` associated with the specified `key` overwriting any existing value.
    extern bool fermyon_spin_2_0_0_key_value_method_store_set(fermyon_spin_2_0_0_key_value_borrow_store_t self, http_trigger_string_t *key, fermyon_spin_2_0_0_rdbms_types_list_u8_t *value, fermyon_spin_2_0_0_key_value_error_t *err);
    // Delete the tuple with the specified `key`
    // 
    // No error is raised if a tuple did not previously exist for `key`.
    extern bool fermyon_spin_2_0_0_key_value_method_store_delete(fermyon_spin_2_0_0_key_value_borrow_store_t self, http_trigger_string_t *key, fermyon_spin_2_0_0_key_value_error_t *err);
    // Return whether a tuple exists for the specified `key`
    extern bool fermyon_spin_2_0_0_key_value_method_store_exists(fermyon_spin_2_0_0_key_value_borrow_store_t self, http_trigger_string_t *key, bool *ret, fermyon_spin_2_0_0_key_value_error_t *err);
    // Return a list of all the keys
    extern bool fermyon_spin_2_0_0_key_value_method_store_get_keys(fermyon_spin_2_0_0_key_value_borrow_store_t self, fermyon_spin_2_0_0_llm_list_string_t *ret, fermyon_spin_2_0_0_key_value_error_t *err);
    
    // Imported Functions from `fermyon:spin/variables@2.0.0`
    // Get an application variable value for the current component.
    // 
    // The name must match one defined in in the component manifest.
    extern bool fermyon_spin_2_0_0_variables_get(http_trigger_string_t *name, http_trigger_string_t *ret, fermyon_spin_2_0_0_variables_error_t *err);
    
    // Imported Functions from `wasi:clocks/wall-clock@0.2.0-rc-2023-10-18`
    // Read the current value of the clock.
    // 
    // This clock is not monotonic, therefore calling this function repeatedly
    // will not necessarily produce a sequence of non-decreasing values.
    // 
    // The returned timestamps represent the number of seconds since
    // 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
    // also known as [Unix Time].
    // 
    // The nanoseconds field of the output is always less than 1000000000.
    // 
    // [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
    // [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
    extern void wasi_clocks_0_2_0_rc_2023_10_18_wall_clock_now(wasi_clocks_0_2_0_rc_2023_10_18_wall_clock_datetime_t *ret);
    // Query the resolution of the clock.
    // 
    // The nanoseconds field of the output is always less than 1000000000.
    extern void wasi_clocks_0_2_0_rc_2023_10_18_wall_clock_resolution(wasi_clocks_0_2_0_rc_2023_10_18_wall_clock_datetime_t *ret);
    
    // Imported Functions from `wasi:clocks/monotonic-clock@0.2.0-rc-2023-10-18`
    // Read the current value of the clock.
    // 
    // The clock is monotonic, therefore calling this function repeatedly will
    // produce a sequence of non-decreasing values.
    extern wasi_clocks_0_2_0_rc_2023_10_18_monotonic_clock_instant_t wasi_clocks_0_2_0_rc_2023_10_18_monotonic_clock_now(void);
    // Query the resolution of the clock.
    extern wasi_clocks_0_2_0_rc_2023_10_18_monotonic_clock_instant_t wasi_clocks_0_2_0_rc_2023_10_18_monotonic_clock_resolution(void);
    // Create a `pollable` which will resolve once the specified time has been
    // reached.
    extern wasi_clocks_0_2_0_rc_2023_10_18_monotonic_clock_own_pollable_t wasi_clocks_0_2_0_rc_2023_10_18_monotonic_clock_subscribe(wasi_clocks_0_2_0_rc_2023_10_18_monotonic_clock_instant_t when, bool absolute);
    
    // Imported Functions from `wasi:clocks/timezone@0.2.0-rc-2023-10-18`
    // Return information needed to display the given `datetime`. This includes
    // the UTC offset, the time zone name, and a flag indicating whether
    // daylight saving time is active.
    // 
    // If the timezone cannot be determined for the given `datetime`, return a
    // `timezone-display` for `UTC` with a `utc-offset` of 0 and no daylight
    // saving time.
    extern void wasi_clocks_0_2_0_rc_2023_10_18_timezone_display(wasi_clocks_0_2_0_rc_2023_10_18_timezone_datetime_t *when, wasi_clocks_0_2_0_rc_2023_10_18_timezone_timezone_display_t *ret);
    // The same as `display`, but only return the UTC offset.
    extern int32_t wasi_clocks_0_2_0_rc_2023_10_18_timezone_utc_offset(wasi_clocks_0_2_0_rc_2023_10_18_timezone_datetime_t *when);
    
    // Imported Functions from `wasi:filesystem/types@0.2.0-rc-2023-10-18`
    // Return a stream for reading from a file, if available.
    // 
    // May fail with an error-code describing why the file cannot be read.
    // 
    // Multiple read, write, and append streams may be active on the same open
    // file and they do not interfere with each other.
    // 
    // Note: This allows using `read-stream`, which is similar to `read` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_read_via_stream(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t offset, wasi_filesystem_0_2_0_rc_2023_10_18_types_own_input_stream_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Return a stream for writing to a file, if available.
    // 
    // May fail with an error-code describing why the file cannot be written.
    // 
    // Note: This allows using `write-stream`, which is similar to `write` in
    // POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_write_via_stream(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t offset, wasi_filesystem_0_2_0_rc_2023_10_18_types_own_output_stream_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Return a stream for appending to a file, if available.
    // 
    // May fail with an error-code describing why the file cannot be appended.
    // 
    // Note: This allows using `write-stream`, which is similar to `write` with
    // `O_APPEND` in in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_append_via_stream(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_own_output_stream_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Provide file advisory information on a descriptor.
    // 
    // This is similar to `posix_fadvise` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_advise(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t offset, wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t length, wasi_filesystem_0_2_0_rc_2023_10_18_types_advice_t advice, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Synchronize the data of a file to disk.
    // 
    // This function succeeds with no effect if the file descriptor is not
    // opened for writing.
    // 
    // Note: This is similar to `fdatasync` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_sync_data(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Get flags associated with a descriptor.
    // 
    // Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
    // 
    // Note: This returns the value that was the `fs_flags` value returned
    // from `fdstat_get` in earlier versions of WASI.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_get_flags(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_flags_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Get the dynamic type of a descriptor.
    // 
    // Note: This returns the same value as the `type` field of the `fd-stat`
    // returned by `stat`, `stat-at` and similar.
    // 
    // Note: This returns similar flags to the `st_mode & S_IFMT` value provided
    // by `fstat` in POSIX.
    // 
    // Note: This returns the value that was the `fs_filetype` value returned
    // from `fdstat_get` in earlier versions of WASI.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_get_type(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_type_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Adjust the size of an open file. If this increases the file's size, the
    // extra bytes are filled with zeros.
    // 
    // Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_set_size(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t size, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Adjust the timestamps of an open file or directory.
    // 
    // Note: This is similar to `futimens` in POSIX.
    // 
    // Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_set_times(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_new_timestamp_t *data_access_timestamp, wasi_filesystem_0_2_0_rc_2023_10_18_types_new_timestamp_t *data_modification_timestamp, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Read from a descriptor, without using and updating the descriptor's offset.
    // 
    // This function returns a list of bytes containing the data that was
    // read, along with a bool which, when true, indicates that the end of the
    // file was reached. The returned list will contain up to `length` bytes; it
    // may return fewer than requested, if the end of the file is reached or
    // if the I/O operation is interrupted.
    // 
    // In the future, this may change to return a `stream<u8, error-code>`.
    // 
    // Note: This is similar to `pread` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_read(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t length, wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t offset, wasi_filesystem_0_2_0_rc_2023_10_18_types_tuple2_list_u8_bool_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Write to a descriptor, without using and updating the descriptor's offset.
    // 
    // It is valid to write past the end of a file; the file is extended to the
    // extent of the write, with bytes between the previous end and the start of
    // the write set to zero.
    // 
    // In the future, this may change to take a `stream<u8, error-code>`.
    // 
    // Note: This is similar to `pwrite` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_write(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_list_u8_t *buffer, wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t offset, wasi_filesystem_0_2_0_rc_2023_10_18_types_filesize_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Read directory entries from a directory.
    // 
    // On filesystems where directories contain entries referring to themselves
    // and their parents, often named `.` and `..` respectively, these entries
    // are omitted.
    // 
    // This always returns a new stream which starts at the beginning of the
    // directory. Multiple streams may be active on the same directory, and they
    // do not interfere with each other.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_read_directory(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_own_directory_entry_stream_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Synchronize the data and metadata of a file to disk.
    // 
    // This function succeeds with no effect if the file descriptor is not
    // opened for writing.
    // 
    // Note: This is similar to `fsync` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_sync(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Create a directory.
    // 
    // Note: This is similar to `mkdirat` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_create_directory_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, http_trigger_string_t *path, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Return the attributes of an open file or directory.
    // 
    // Note: This is similar to `fstat` in POSIX, except that it does not return
    // device and inode information. For testing whether two descriptors refer to
    // the same underlying filesystem object, use `is-same-object`. To obtain
    // additional data that can be used do determine whether a file has been
    // modified, use `metadata-hash`.
    // 
    // Note: This was called `fd_filestat_get` in earlier versions of WASI.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_stat(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_stat_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Return the attributes of a file or directory.
    // 
    // Note: This is similar to `fstatat` in POSIX, except that it does not
    // return device and inode information. See the `stat` description for a
    // discussion of alternatives.
    // 
    // Note: This was called `path_filestat_get` in earlier versions of WASI.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_stat_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_path_flags_t path_flags, http_trigger_string_t *path, wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_stat_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Adjust the timestamps of a file or directory.
    // 
    // Note: This is similar to `utimensat` in POSIX.
    // 
    // Note: This was called `path_filestat_set_times` in earlier versions of
    // WASI.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_set_times_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_path_flags_t path_flags, http_trigger_string_t *path, wasi_filesystem_0_2_0_rc_2023_10_18_types_new_timestamp_t *data_access_timestamp, wasi_filesystem_0_2_0_rc_2023_10_18_types_new_timestamp_t *data_modification_timestamp, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Create a hard link.
    // 
    // Note: This is similar to `linkat` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_link_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_path_flags_t old_path_flags, http_trigger_string_t *old_path, wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t new_descriptor, http_trigger_string_t *new_path, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Open a file or directory.
    // 
    // The returned descriptor is not guaranteed to be the lowest-numbered
    // descriptor not currently open/ it is randomized to prevent applications
    // from depending on making assumptions about indexes, since this is
    // error-prone in multi-threaded contexts. The returned descriptor is
    // guaranteed to be less than 2**31.
    // 
    // If `flags` contains `descriptor-flags::mutate-directory`, and the base
    // descriptor doesn't have `descriptor-flags::mutate-directory` set,
    // `open-at` fails with `error-code::read-only`.
    // 
    // If `flags` contains `write` or `mutate-directory`, or `open-flags`
    // contains `truncate` or `create`, and the base descriptor doesn't have
    // `descriptor-flags::mutate-directory` set, `open-at` fails with
    // `error-code::read-only`.
    // 
    // Note: This is similar to `openat` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_open_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_path_flags_t path_flags, http_trigger_string_t *path, wasi_filesystem_0_2_0_rc_2023_10_18_types_open_flags_t open_flags, wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_flags_t flags, wasi_filesystem_0_2_0_rc_2023_10_18_types_modes_t modes, wasi_filesystem_0_2_0_rc_2023_10_18_types_own_descriptor_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Read the contents of a symbolic link.
    // 
    // If the contents contain an absolute or rooted path in the underlying
    // filesystem, this function fails with `error-code::not-permitted`.
    // 
    // Note: This is similar to `readlinkat` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_readlink_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, http_trigger_string_t *path, http_trigger_string_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Remove a directory.
    // 
    // Return `error-code::not-empty` if the directory is not empty.
    // 
    // Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_remove_directory_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, http_trigger_string_t *path, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Rename a filesystem object.
    // 
    // Note: This is similar to `renameat` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_rename_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, http_trigger_string_t *old_path, wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t new_descriptor, http_trigger_string_t *new_path, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Create a symbolic link (also known as a "symlink").
    // 
    // If `old-path` starts with `/`, the function fails with
    // `error-code::not-permitted`.
    // 
    // Note: This is similar to `symlinkat` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_symlink_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, http_trigger_string_t *old_path, http_trigger_string_t *new_path, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Check accessibility of a filesystem path.
    // 
    // Check whether the given filesystem path names an object which is
    // readable, writable, or executable, or whether it exists.
    // 
    // This does not a guarantee that subsequent accesses will succeed, as
    // filesystem permissions may be modified asynchronously by external
    // entities.
    // 
    // Note: This is similar to `faccessat` with the `AT_EACCESS` flag in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_access_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_path_flags_t path_flags, http_trigger_string_t *path, wasi_filesystem_0_2_0_rc_2023_10_18_types_access_type_t *type, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Unlink a filesystem object that is not a directory.
    // 
    // Return `error-code::is-directory` if the path refers to a directory.
    // Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_unlink_file_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, http_trigger_string_t *path, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Change the permissions of a filesystem object that is not a directory.
    // 
    // Note that the ultimate meanings of these permissions is
    // filesystem-specific.
    // 
    // Note: This is similar to `fchmodat` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_change_file_permissions_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_path_flags_t path_flags, http_trigger_string_t *path, wasi_filesystem_0_2_0_rc_2023_10_18_types_modes_t modes, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Change the permissions of a directory.
    // 
    // Note that the ultimate meanings of these permissions is
    // filesystem-specific.
    // 
    // Unlike in POSIX, the `executable` flag is not reinterpreted as a "search"
    // flag. `read` on a directory implies readability and searchability, and
    // `execute` is not valid for directories.
    // 
    // Note: This is similar to `fchmodat` in POSIX.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_change_directory_permissions_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_path_flags_t path_flags, http_trigger_string_t *path, wasi_filesystem_0_2_0_rc_2023_10_18_types_modes_t modes, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Request a shared advisory lock for an open file.
    // 
    // This requests a *shared* lock; more than one shared lock can be held for
    // a file at the same time.
    // 
    // If the open file has an exclusive lock, this function downgrades the lock
    // to a shared lock. If it has a shared lock, this function has no effect.
    // 
    // This requests an *advisory* lock, meaning that the file could be accessed
    // by other programs that don't hold the lock.
    // 
    // It is unspecified how shared locks interact with locks acquired by
    // non-WASI programs.
    // 
    // This function blocks until the lock can be acquired.
    // 
    // Not all filesystems support locking; on filesystems which don't support
    // locking, this function returns `error-code::unsupported`.
    // 
    // Note: This is similar to `flock(fd, LOCK_SH)` in Unix.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_lock_shared(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Request an exclusive advisory lock for an open file.
    // 
    // This requests an *exclusive* lock; no other locks may be held for the
    // file while an exclusive lock is held.
    // 
    // If the open file has a shared lock and there are no exclusive locks held
    // for the file, this function upgrades the lock to an exclusive lock. If the
    // open file already has an exclusive lock, this function has no effect.
    // 
    // This requests an *advisory* lock, meaning that the file could be accessed
    // by other programs that don't hold the lock.
    // 
    // It is unspecified whether this function succeeds if the file descriptor
    // is not opened for writing. It is unspecified how exclusive locks interact
    // with locks acquired by non-WASI programs.
    // 
    // This function blocks until the lock can be acquired.
    // 
    // Not all filesystems support locking; on filesystems which don't support
    // locking, this function returns `error-code::unsupported`.
    // 
    // Note: This is similar to `flock(fd, LOCK_EX)` in Unix.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_lock_exclusive(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Request a shared advisory lock for an open file.
    // 
    // This requests a *shared* lock; more than one shared lock can be held for
    // a file at the same time.
    // 
    // If the open file has an exclusive lock, this function downgrades the lock
    // to a shared lock. If it has a shared lock, this function has no effect.
    // 
    // This requests an *advisory* lock, meaning that the file could be accessed
    // by other programs that don't hold the lock.
    // 
    // It is unspecified how shared locks interact with locks acquired by
    // non-WASI programs.
    // 
    // This function returns `error-code::would-block` if the lock cannot be
    // acquired.
    // 
    // Not all filesystems support locking; on filesystems which don't support
    // locking, this function returns `error-code::unsupported`.
    // 
    // Note: This is similar to `flock(fd, LOCK_SH | LOCK_NB)` in Unix.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_try_lock_shared(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Request an exclusive advisory lock for an open file.
    // 
    // This requests an *exclusive* lock; no other locks may be held for the
    // file while an exclusive lock is held.
    // 
    // If the open file has a shared lock and there are no exclusive locks held
    // for the file, this function upgrades the lock to an exclusive lock. If the
    // open file already has an exclusive lock, this function has no effect.
    // 
    // This requests an *advisory* lock, meaning that the file could be accessed
    // by other programs that don't hold the lock.
    // 
    // It is unspecified whether this function succeeds if the file descriptor
    // is not opened for writing. It is unspecified how exclusive locks interact
    // with locks acquired by non-WASI programs.
    // 
    // This function returns `error-code::would-block` if the lock cannot be
    // acquired.
    // 
    // Not all filesystems support locking; on filesystems which don't support
    // locking, this function returns `error-code::unsupported`.
    // 
    // Note: This is similar to `flock(fd, LOCK_EX | LOCK_NB)` in Unix.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_try_lock_exclusive(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Release a shared or exclusive lock on an open file.
    // 
    // Note: This is similar to `flock(fd, LOCK_UN)` in Unix.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_unlock(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Test whether two descriptors refer to the same filesystem object.
    // 
    // In POSIX, this corresponds to testing whether the two descriptors have the
    // same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
    // wasi-filesystem does not expose device and inode numbers, so this function
    // may be used instead.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_is_same_object(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t other);
    // Return a hash of the metadata associated with a filesystem object referred
    // to by a descriptor.
    // 
    // This returns a hash of the last-modification timestamp and file size, and
    // may also include the inode number, device number, birth timestamp, and
    // other metadata fields that may change when the file is modified or
    // replaced. It may also include a secret value chosen by the
    // implementation and not otherwise exposed.
    // 
    // Implementations are encourated to provide the following properties:
    // 
    // - If the file is not modified or replaced, the computed hash value should
    // usually not change.
    // - If the object is modified or replaced, the computed hash value should
    // usually change.
    // - The inputs to the hash should not be easily computable from the
    // computed hash.
    // 
    // However, none of these is required.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_metadata_hash(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_metadata_hash_value_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Return a hash of the metadata associated with a filesystem object referred
    // to by a directory descriptor and a relative path.
    // 
    // This performs the same hash computation as `metadata-hash`.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_descriptor_metadata_hash_at(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_path_flags_t path_flags, http_trigger_string_t *path, wasi_filesystem_0_2_0_rc_2023_10_18_types_metadata_hash_value_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Read a single directory entry from a `directory-entry-stream`.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_method_directory_entry_stream_read_directory_entry(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_directory_entry_stream_t self, wasi_filesystem_0_2_0_rc_2023_10_18_types_option_directory_entry_t *ret, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *err);
    // Attempts to extract a filesystem-related `error-code` from the stream
    // `error` provided.
    // 
    // Stream operations which return `stream-error::last-operation-failed`
    // have a payload with more information about the operation that failed.
    // This payload can be passed through to this function to see if there's
    // filesystem-related information about the error to return.
    // 
    // Note that this function is fallible because not all stream-related
    // errors are filesystem-related errors.
    extern bool wasi_filesystem_0_2_0_rc_2023_10_18_types_filesystem_error_code(wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_error_t err_, wasi_filesystem_0_2_0_rc_2023_10_18_types_error_code_t *ret);
    
    // Imported Functions from `wasi:filesystem/preopens@0.2.0-rc-2023-10-18`
    // Return the set of preopened directories, and their path.
    extern void wasi_filesystem_0_2_0_rc_2023_10_18_preopens_get_directories(wasi_filesystem_0_2_0_rc_2023_10_18_preopens_list_tuple2_own_descriptor_string_t *ret);
    
    // Imported Functions from `wasi:sockets/instance-network@0.2.0-rc-2023-10-18`
    // Get a handle to the default network.
    extern wasi_sockets_0_2_0_rc_2023_10_18_instance_network_own_network_t wasi_sockets_0_2_0_rc_2023_10_18_instance_network_instance_network(void);
    
    // Imported Functions from `wasi:sockets/ip-name-lookup@0.2.0-rc-2023-10-18`
    // Resolve an internet host name to a list of IP addresses.
    // 
    // See the wasi-socket proposal README.md for a comparison with getaddrinfo.
    // 
    // # Parameters
    // - `name`: The name to look up. IP addresses are not allowed. Unicode domain names are automatically converted
    // to ASCII using IDNA encoding.
    // - `address-family`: If provided, limit the results to addresses of this specific address family.
    // - `include-unavailable`: When set to true, this function will also return addresses of which the runtime
    // thinks (or knows) can't be connected to at the moment. For example, this will return IPv6 addresses on
    // systems without an active IPv6 interface. Notes:
    // - Even when no public IPv6 interfaces are present or active, names like "localhost" can still resolve to an IPv6 address.
    // - Whatever is "available" or "unavailable" is volatile and can change everytime a network cable is unplugged.
    // 
    // This function never blocks. It either immediately fails or immediately returns successfully with a `resolve-address-stream`
    // that can be used to (asynchronously) fetch the results.
    // 
    // At the moment, the stream never completes successfully with 0 items. Ie. the first call
    // to `resolve-next-address` never returns `ok(none)`. This may change in the future.
    // 
    // # Typical errors
    // - `invalid-argument`:     `name` is a syntactically invalid domain name.
    // - `invalid-argument`:     `name` is an IP address.
    // - `not-supported`:        The specified `address-family` is not supported. (EAI_FAMILY)
    // 
    // # References:
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html>
    // - <https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo>
    // - <https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&sektion=3>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_resolve_addresses(wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_borrow_network_t network, http_trigger_string_t *name, wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_ip_address_family_t *maybe_address_family, bool include_unavailable, wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_own_resolve_address_stream_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_error_code_t *err);
    // Returns the next address from the resolver.
    // 
    // This function should be called multiple times. On each call, it will
    // return the next address in connection order preference. If all
    // addresses have been exhausted, this function returns `none`.
    // 
    // This function never returns IPv4-mapped IPv6 addresses.
    // 
    // # Typical errors
    // - `name-unresolvable`:          Name does not exist or has no suitable associated IP addresses. (EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY)
    // - `temporary-resolver-failure`: A temporary failure in name resolution occurred. (EAI_AGAIN)
    // - `permanent-resolver-failure`: A permanent failure in name resolution occurred. (EAI_FAIL)
    // - `would-block`:                A result is not available yet. (EWOULDBLOCK, EAGAIN)
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_method_resolve_address_stream_resolve_next_address(wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_borrow_resolve_address_stream_t self, wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_option_ip_address_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_error_code_t *err);
    // Create a `pollable` which will resolve once the stream is ready for I/O.
    // 
    // Note: this function is here for WASI Preview2 only.
    // It's planned to be removed when `future` is natively supported in Preview3.
    extern wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_own_pollable_t wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_method_resolve_address_stream_subscribe(wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_borrow_resolve_address_stream_t self);
    
    // Imported Functions from `wasi:sockets/tcp@0.2.0-rc-2023-10-18`
    // Bind the socket to a specific network on the provided IP address and port.
    // 
    // If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
    // network interface(s) to bind to.
    // If the TCP/UDP port is zero, the socket will be bound to a random free port.
    // 
    // When a socket is not explicitly bound, the first invocation to a listen or connect operation will
    // implicitly bind the socket.
    // 
    // Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.
    // 
    // # Typical `start` errors
    // - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
    // - `invalid-argument`:          `local-address` is not a unicast address. (EINVAL)
    // - `invalid-argument`:          `local-address` is an IPv4-mapped IPv6 address, but the socket has `ipv6-only` enabled. (EINVAL)
    // - `invalid-state`:             The socket is already bound. (EINVAL)
    // 
    // # Typical `finish` errors
    // - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
    // - `address-in-use`:            Address is already in use. (EADDRINUSE)
    // - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to. (EADDRNOTAVAIL)
    // - `not-in-progress`:           A `bind` operation is not in progress.
    // - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
    // - <https://man7.org/linux/man-pages/man2/bind.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
    // - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_start_bind(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_network_t network, wasi_sockets_0_2_0_rc_2023_10_18_tcp_ip_socket_address_t *local_address, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_finish_bind(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // Connect to a remote endpoint.
    // 
    // On success:
    // - the socket is transitioned into the Connection state
    // - a pair of streams is returned that can be used to read & write to the connection
    // 
    // POSIX mentions:
    // > If connect() fails, the state of the socket is unspecified. Conforming applications should
    // > close the file descriptor and create a new socket before attempting to reconnect.
    // 
    // WASI prescribes the following behavior:
    // - If `connect` fails because an input/state validation error, the socket should remain usable.
    // - If a connection was actually attempted but failed, the socket should become unusable for further network communication.
    // Besides `drop`, any method after such a failure may return an error.
    // 
    // # Typical `start` errors
    // - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
    // - `invalid-argument`:          `remote-address` is not a unicast address. (EINVAL, ENETUNREACH on Linux, EAFNOSUPPORT on MacOS)
    // - `invalid-argument`:          `remote-address` is an IPv4-mapped IPv6 address, but the socket has `ipv6-only` enabled. (EINVAL, EADDRNOTAVAIL on Illumos)
    // - `invalid-argument`:          `remote-address` is a non-IPv4-mapped IPv6 address, but the socket was bound to a specific IPv4-mapped IPv6 address. (or vice versa)
    // - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)
    // - `invalid-argument`:          The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)
    // - `invalid-argument`:          The socket is already attached to a different network. The `network` passed to `connect` must be identical to the one passed to `bind`.
    // - `invalid-state`:             The socket is already in the Connection state. (EISCONN)
    // - `invalid-state`:             The socket is already in the Listener state. (EOPNOTSUPP, EINVAL on Windows)
    // 
    // # Typical `finish` errors
    // - `timeout`:                   Connection timed out. (ETIMEDOUT)
    // - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)
    // - `connection-reset`:          The connection was reset. (ECONNRESET)
    // - `connection-aborted`:        The connection was aborted. (ECONNABORTED)
    // - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN)
    // - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
    // - `not-in-progress`:           A `connect` operation is not in progress.
    // - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
    // - <https://man7.org/linux/man-pages/man2/connect.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
    // - <https://man.freebsd.org/cgi/man.cgi?connect>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_start_connect(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_network_t network, wasi_sockets_0_2_0_rc_2023_10_18_tcp_ip_socket_address_t *remote_address, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_finish_connect(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_tcp_tuple2_own_input_stream_own_output_stream_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // Start listening for new connections.
    // 
    // Transitions the socket into the Listener state.
    // 
    // Unlike POSIX:
    // - this function is async. This enables interactive WASI hosts to inject permission prompts.
    // - the socket must already be explicitly bound.
    // 
    // # Typical `start` errors
    // - `invalid-state`:             The socket is not bound to any local address. (EDESTADDRREQ)
    // - `invalid-state`:             The socket is already in the Connection state. (EISCONN, EINVAL on BSD)
    // - `invalid-state`:             The socket is already in the Listener state.
    // 
    // # Typical `finish` errors
    // - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE)
    // - `not-in-progress`:           A `listen` operation is not in progress.
    // - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>
    // - <https://man7.org/linux/man-pages/man2/listen.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>
    // - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_start_listen(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_finish_listen(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // Accept a new client socket.
    // 
    // The returned socket is bound and in the Connection state. The following properties are inherited from the listener socket:
    // - `address-family`
    // - `ipv6-only`
    // - `keep-alive`
    // - `no-delay`
    // - `unicast-hop-limit`
    // - `receive-buffer-size`
    // - `send-buffer-size`
    // 
    // On success, this function returns the newly accepted client socket along with
    // a pair of streams that can be used to read & write to the connection.
    // 
    // # Typical errors
    // - `invalid-state`:      Socket is not in the Listener state. (EINVAL)
    // - `would-block`:        No pending connections at the moment. (EWOULDBLOCK, EAGAIN)
    // - `connection-aborted`: An incoming connection was pending, but was terminated by the client before this listener could accept it. (ECONNABORTED)
    // - `new-socket-limit`:   The new socket resource could not be created because of a system limit. (EMFILE, ENFILE)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>
    // - <https://man7.org/linux/man-pages/man2/accept.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>
    // - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_accept(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_tcp_tuple3_own_tcp_socket_own_input_stream_own_output_stream_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // Get the bound local address.
    // 
    // POSIX mentions:
    // > If the socket has not been bound to a local name, the value
    // > stored in the object pointed to by `address` is unspecified.
    // 
    // WASI is stricter and requires `local-address` to return `invalid-state` when the socket hasn't been bound yet.
    // 
    // # Typical errors
    // - `invalid-state`: The socket is not bound to any local address.
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
    // - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
    // - <https://man.freebsd.org/cgi/man.cgi?getsockname>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_local_address(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_tcp_ip_socket_address_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // Get the remote address.
    // 
    // # Typical errors
    // - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
    // - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
    // - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_remote_address(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_tcp_ip_socket_address_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // Whether this is a IPv4 or IPv6 socket.
    // 
    // Equivalent to the SO_DOMAIN socket option.
    extern wasi_sockets_0_2_0_rc_2023_10_18_tcp_ip_address_family_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_address_family(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self);
    // Whether IPv4 compatibility (dual-stack) mode is disabled or not.
    // 
    // Equivalent to the IPV6_V6ONLY socket option.
    // 
    // # Typical errors
    // - `invalid-state`:        (set) The socket is already bound.
    // - `not-supported`:        (get/set) `this` socket is an IPv4 socket.
    // - `not-supported`:        (set) Host does not support dual-stack sockets. (Implementations are not required to.)
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_ipv6_only(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, bool *ret, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_set_ipv6_only(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, bool value, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // Hints the desired listen queue size. Implementations are free to ignore this.
    // 
    // # Typical errors
    // - `not-supported`:        (set) The platform does not support changing the backlog size after the initial listen.
    // - `invalid-state`:        (set) The socket is already in the Connection state.
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_set_listen_backlog_size(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, uint64_t value, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // Equivalent to the SO_KEEPALIVE socket option.
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_keep_alive(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, bool *ret, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_set_keep_alive(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, bool value, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // Equivalent to the TCP_NODELAY socket option.
    // 
    // The default value is `false`.
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_no_delay(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, bool *ret, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_set_no_delay(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, bool value, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
    // 
    // # Typical errors
    // - `invalid-argument`:     (set) The TTL value must be 1 or higher.
    // - `invalid-state`:        (set) The socket is already in the Connection state.
    // - `invalid-state`:        (set) The socket is already in the Listener state.
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_unicast_hop_limit(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, uint8_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_set_unicast_hop_limit(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, uint8_t value, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // The kernel buffer space reserved for sends/receives on this socket.
    // 
    // Note #1: an implementation may choose to cap or round the buffer size when setting the value.
    // In other words, after setting a value, reading the same setting back may return a different value.
    // 
    // Note #2: there is not necessarily a direct relationship between the kernel buffer size and the bytes of
    // actual data to be sent/received by the application, because the kernel might also use the buffer space
    // for internal metadata structures.
    // 
    // Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
    // 
    // # Typical errors
    // - `invalid-state`:        (set) The socket is already in the Connection state.
    // - `invalid-state`:        (set) The socket is already in the Listener state.
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_receive_buffer_size(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, uint64_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_set_receive_buffer_size(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, uint64_t value, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_send_buffer_size(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, uint64_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_set_send_buffer_size(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, uint64_t value, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    // Create a `pollable` which will resolve once the socket is ready for I/O.
    // 
    // Note: this function is here for WASI Preview2 only.
    // It's planned to be removed when `future` is natively supported in Preview3.
    extern wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_pollable_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_subscribe(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self);
    // Initiate a graceful shutdown.
    // 
    // - receive: the socket is not expecting to receive any more data from the peer. All subsequent read
    // operations on the `input-stream` associated with this socket will return an End Of Stream indication.
    // Any data still in the receive queue at time of calling `shutdown` will be discarded.
    // - send: the socket is not expecting to send any more data to the peer. All subsequent write
    // operations on the `output-stream` associated with this socket will return an error.
    // - both: same effect as receive & send combined.
    // 
    // The shutdown function does not close (drop) the socket.
    // 
    // # Typical errors
    // - `invalid-state`: The socket is not in the Connection state. (ENOTCONN)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html>
    // - <https://man7.org/linux/man-pages/man2/shutdown.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-shutdown>
    // - <https://man.freebsd.org/cgi/man.cgi?query=shutdown&sektion=2>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_method_tcp_socket_shutdown(wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_tcp_shutdown_type_t shutdown_type, wasi_sockets_0_2_0_rc_2023_10_18_tcp_error_code_t *err);
    
    // Imported Functions from `wasi:sockets/tcp-create-socket@0.2.0-rc-2023-10-18`
    // Create a new TCP socket.
    // 
    // Similar to `socket(AF_INET or AF_INET6, SOCK_STREAM, IPPROTO_TCP)` in POSIX.
    // 
    // This function does not require a network capability handle. This is considered to be safe because
    // at time of creation, the socket is not bound to any `network` yet. Up to the moment `bind`/`listen`/`connect`
    // is called, the socket is effectively an in-memory configuration object, unable to communicate with the outside world.
    // 
    // All sockets are non-blocking. Use the wasi-poll interface to block on asynchronous operations.
    // 
    // # Typical errors
    // - `not-supported`:     The specified `address-family` is not supported. (EAFNOSUPPORT)
    // - `new-socket-limit`:  The new socket resource could not be created because of a system limit. (EMFILE, ENFILE)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
    // - <https://man7.org/linux/man-pages/man2/socket.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
    // - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_create_tcp_socket(wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_ip_address_family_t address_family, wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_own_tcp_socket_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_error_code_t *err);
    
    // Imported Functions from `wasi:sockets/udp@0.2.0-rc-2023-10-18`
    // Bind the socket to a specific network on the provided IP address and port.
    // 
    // If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
    // network interface(s) to bind to.
    // If the TCP/UDP port is zero, the socket will be bound to a random free port.
    // 
    // When a socket is not explicitly bound, the first invocation to connect will implicitly bind the socket.
    // 
    // Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.
    // 
    // # Typical `start` errors
    // - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
    // - `invalid-state`:             The socket is already bound. (EINVAL)
    // 
    // # Typical `finish` errors
    // - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
    // - `address-in-use`:            Address is already in use. (EADDRINUSE)
    // - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to. (EADDRNOTAVAIL)
    // - `not-in-progress`:           A `bind` operation is not in progress.
    // - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
    // - <https://man7.org/linux/man-pages/man2/bind.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
    // - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_start_bind(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_network_t network, wasi_sockets_0_2_0_rc_2023_10_18_udp_ip_socket_address_t *local_address, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_finish_bind(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    // Set the destination address.
    // 
    // The local-address is updated based on the best network path to `remote-address`.
    // 
    // When a destination address is set:
    // - all receive operations will only return datagrams sent from the provided `remote-address`.
    // - the `send` function can only be used to send to this destination.
    // 
    // Note that this function does not generate any network traffic and the peer is not aware of this "connection".
    // 
    // Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.
    // 
    // # Typical `start` errors
    // - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
    // - `invalid-argument`:          `remote-address` is a non-IPv4-mapped IPv6 address, but the socket was bound to a specific IPv4-mapped IPv6 address. (or vice versa)
    // - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
    // - `invalid-argument`:          The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
    // - `invalid-argument`:          The socket is already bound to a different network. The `network` passed to `connect` must be identical to the one passed to `bind`.
    // 
    // # Typical `finish` errors
    // - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
    // - `not-in-progress`:           A `connect` operation is not in progress.
    // - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
    // - <https://man7.org/linux/man-pages/man2/connect.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
    // - <https://man.freebsd.org/cgi/man.cgi?connect>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_start_connect(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_network_t network, wasi_sockets_0_2_0_rc_2023_10_18_udp_ip_socket_address_t *remote_address, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_finish_connect(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    // Receive messages on the socket.
    // 
    // This function attempts to receive up to `max-results` datagrams on the socket without blocking.
    // The returned list may contain fewer elements than requested, but never more.
    // If `max-results` is 0, this function returns successfully with an empty list.
    // 
    // # Typical errors
    // - `invalid-state`:      The socket is not bound to any local address. (EINVAL)
    // - `remote-unreachable`: The remote address is not reachable. (ECONNREFUSED, ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN)
    // - `would-block`:        There is no pending data available to be read at the moment. (EWOULDBLOCK, EAGAIN)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>
    // - <https://man7.org/linux/man-pages/man2/recv.2.html>
    // - <https://man7.org/linux/man-pages/man2/recvmmsg.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>
    // - <https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms741687(v=vs.85)>
    // - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_receive(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, uint64_t max_results, wasi_sockets_0_2_0_rc_2023_10_18_udp_list_datagram_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    // Send messages on the socket.
    // 
    // This function attempts to send all provided `datagrams` on the socket without blocking and
    // returns how many messages were actually sent (or queued for sending).
    // 
    // This function semantically behaves the same as iterating the `datagrams` list and sequentially
    // sending each individual datagram until either the end of the list has been reached or the first error occurred.
    // If at least one datagram has been sent successfully, this function never returns an error.
    // 
    // If the input list is empty, the function returns `ok(0)`.
    // 
    // The remote address option is required. To send a message to the "connected" peer,
    // call `remote-address` to get their address.
    // 
    // # Typical errors
    // - `invalid-argument`:        The `remote-address` has the wrong address family. (EAFNOSUPPORT)
    // - `invalid-argument`:        `remote-address` is a non-IPv4-mapped IPv6 address, but the socket was bound to a specific IPv4-mapped IPv6 address. (or vice versa)
    // - `invalid-argument`:        The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
    // - `invalid-argument`:        The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
    // - `invalid-argument`:        The socket is in "connected" mode and the `datagram.remote-address` does not match the address passed to `connect`. (EISCONN)
    // - `invalid-state`:           The socket is not bound to any local address. Unlike POSIX, this function does not perform an implicit bind.
    // - `remote-unreachable`:      The remote address is not reachable. (ECONNREFUSED, ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN)
    // - `datagram-too-large`:      The datagram is too large. (EMSGSIZE)
    // - `would-block`:             The send buffer is currently full. (EWOULDBLOCK, EAGAIN)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>
    // - <https://man7.org/linux/man-pages/man2/send.2.html>
    // - <https://man7.org/linux/man-pages/man2/sendmmsg.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>
    // - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_send(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_udp_list_datagram_t *datagrams, uint64_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    // Get the current bound address.
    // 
    // POSIX mentions:
    // > If the socket has not been bound to a local name, the value
    // > stored in the object pointed to by `address` is unspecified.
    // 
    // WASI is stricter and requires `local-address` to return `invalid-state` when the socket hasn't been bound yet.
    // 
    // # Typical errors
    // - `invalid-state`: The socket is not bound to any local address.
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
    // - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
    // - <https://man.freebsd.org/cgi/man.cgi?getsockname>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_local_address(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_udp_ip_socket_address_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    // Get the address set with `connect`.
    // 
    // # Typical errors
    // - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
    // 
    // # References
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
    // - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
    // - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_remote_address(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, wasi_sockets_0_2_0_rc_2023_10_18_udp_ip_socket_address_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    // Whether this is a IPv4 or IPv6 socket.
    // 
    // Equivalent to the SO_DOMAIN socket option.
    extern wasi_sockets_0_2_0_rc_2023_10_18_udp_ip_address_family_t wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_address_family(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self);
    // Whether IPv4 compatibility (dual-stack) mode is disabled or not.
    // 
    // Equivalent to the IPV6_V6ONLY socket option.
    // 
    // # Typical errors
    // - `not-supported`:        (get/set) `this` socket is an IPv4 socket.
    // - `invalid-state`:        (set) The socket is already bound.
    // - `not-supported`:        (set) Host does not support dual-stack sockets. (Implementations are not required to.)
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_ipv6_only(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, bool *ret, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_set_ipv6_only(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, bool value, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    // Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_unicast_hop_limit(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, uint8_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_set_unicast_hop_limit(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, uint8_t value, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    // The kernel buffer space reserved for sends/receives on this socket.
    // 
    // Note #1: an implementation may choose to cap or round the buffer size when setting the value.
    // In other words, after setting a value, reading the same setting back may return a different value.
    // 
    // Note #2: there is not necessarily a direct relationship between the kernel buffer size and the bytes of
    // actual data to be sent/received by the application, because the kernel might also use the buffer space
    // for internal metadata structures.
    // 
    // Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_receive_buffer_size(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, uint64_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_set_receive_buffer_size(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, uint64_t value, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_send_buffer_size(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, uint64_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_set_send_buffer_size(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self, uint64_t value, wasi_sockets_0_2_0_rc_2023_10_18_udp_error_code_t *err);
    // Create a `pollable` which will resolve once the socket is ready for I/O.
    // 
    // Note: this function is here for WASI Preview2 only.
    // It's planned to be removed when `future` is natively supported in Preview3.
    extern wasi_sockets_0_2_0_rc_2023_10_18_udp_own_pollable_t wasi_sockets_0_2_0_rc_2023_10_18_udp_method_udp_socket_subscribe(wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t self);
    
    // Imported Functions from `wasi:sockets/udp-create-socket@0.2.0-rc-2023-10-18`
    // Create a new UDP socket.
    // 
    // Similar to `socket(AF_INET or AF_INET6, SOCK_DGRAM, IPPROTO_UDP)` in POSIX.
    // 
    // This function does not require a network capability handle. This is considered to be safe because
    // at time of creation, the socket is not bound to any `network` yet. Up to the moment `bind`/`connect` is called,
    // the socket is effectively an in-memory configuration object, unable to communicate with the outside world.
    // 
    // All sockets are non-blocking. Use the wasi-poll interface to block on asynchronous operations.
    // 
    // # Typical errors
    // - `not-supported`:     The specified `address-family` is not supported. (EAFNOSUPPORT)
    // - `new-socket-limit`:  The new socket resource could not be created because of a system limit. (EMFILE, ENFILE)
    // 
    // # References:
    // - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
    // - <https://man7.org/linux/man-pages/man2/socket.2.html>
    // - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
    // - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
    extern bool wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_create_udp_socket(wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_ip_address_family_t address_family, wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_own_udp_socket_t *ret, wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_error_code_t *err);
    
    // Imported Functions from `wasi:random/random@0.2.0-rc-2023-10-18`
    // Return `len` cryptographically-secure random or pseudo-random bytes.
    // 
    // This function must produce data at least as cryptographically secure and
    // fast as an adequately seeded cryptographically-secure pseudo-random
    // number generator (CSPRNG). It must not block, from the perspective of
    // the calling program, under any circumstances, including on the first
    // request and on requests for numbers of bytes. The returned data must
    // always be unpredictable.
    // 
    // This function must always return fresh data. Deterministic environments
    // must omit this function, rather than implementing it with deterministic
    // data.
    extern void wasi_random_0_2_0_rc_2023_10_18_random_get_random_bytes(uint64_t len, wasi_random_0_2_0_rc_2023_10_18_random_list_u8_t *ret);
    // Return a cryptographically-secure random or pseudo-random `u64` value.
    // 
    // This function returns the same type of data as `get-random-bytes`,
    // represented as a `u64`.
    extern uint64_t wasi_random_0_2_0_rc_2023_10_18_random_get_random_u64(void);
    
    // Imported Functions from `wasi:random/insecure@0.2.0-rc-2023-10-18`
    // Return `len` insecure pseudo-random bytes.
    // 
    // This function is not cryptographically secure. Do not use it for
    // anything related to security.
    // 
    // There are no requirements on the values of the returned bytes, however
    // implementations are encouraged to return evenly distributed values with
    // a long period.
    extern void wasi_random_0_2_0_rc_2023_10_18_insecure_get_insecure_random_bytes(uint64_t len, wasi_random_0_2_0_rc_2023_10_18_random_list_u8_t *ret);
    // Return an insecure pseudo-random `u64` value.
    // 
    // This function returns the same type of pseudo-random data as
    // `get-insecure-random-bytes`, represented as a `u64`.
    extern uint64_t wasi_random_0_2_0_rc_2023_10_18_insecure_get_insecure_random_u64(void);
    
    // Imported Functions from `wasi:random/insecure-seed@0.2.0-rc-2023-10-18`
    // Return a 128-bit value that may contain a pseudo-random value.
    // 
    // The returned value is not required to be computed from a CSPRNG, and may
    // even be entirely deterministic. Host implementations are encouraged to
    // provide pseudo-random values to any program exposed to
    // attacker-controlled content, to enable DoS protection built into many
    // languages' hash-map implementations.
    // 
    // This function is intended to only be called once, by a source language
    // to initialize Denial Of Service (DoS) protection in its hash-map
    // implementation.
    // 
    // # Expected future evolution
    // 
    // This will likely be changed to a value import, to prevent it from being
    // called multiple times and potentially used for purposes other than DoS
    // protection.
    extern void wasi_random_0_2_0_rc_2023_10_18_insecure_seed_insecure_seed(wasi_random_0_2_0_rc_2023_10_18_insecure_seed_tuple2_u64_u64_t *ret);
    
    // Imported Functions from `wasi:cli/environment@0.2.0-rc-2023-10-18`
    // Get the POSIX-style environment variables.
    // 
    // Each environment variable is provided as a pair of string variable names
    // and string value.
    // 
    // Morally, these are a value import, but until value imports are available
    // in the component model, this import function should return the same
    // values each time it is called.
    extern void wasi_cli_0_2_0_rc_2023_10_18_environment_get_environment(wasi_cli_0_2_0_rc_2023_10_18_environment_list_tuple2_string_string_t *ret);
    // Get the POSIX-style arguments to the program.
    extern void wasi_cli_0_2_0_rc_2023_10_18_environment_get_arguments(wasi_cli_0_2_0_rc_2023_10_18_environment_list_string_t *ret);
    // Return a path that programs should use as their initial current working
    // directory, interpreting `.` as shorthand for this.
    extern bool wasi_cli_0_2_0_rc_2023_10_18_environment_initial_cwd(http_trigger_string_t *ret);
    
    // Imported Functions from `wasi:cli/exit@0.2.0-rc-2023-10-18`
    // Exit the current instance and any linked instances.
    extern void wasi_cli_0_2_0_rc_2023_10_18_exit_exit(wasi_cli_0_2_0_rc_2023_10_18_exit_result_void_void_t *status);
    
    // Imported Functions from `wasi:cli/stdin@0.2.0-rc-2023-10-18`
    extern wasi_cli_0_2_0_rc_2023_10_18_stdin_own_input_stream_t wasi_cli_0_2_0_rc_2023_10_18_stdin_get_stdin(void);
    
    // Imported Functions from `wasi:cli/stdout@0.2.0-rc-2023-10-18`
    extern wasi_cli_0_2_0_rc_2023_10_18_stdout_own_output_stream_t wasi_cli_0_2_0_rc_2023_10_18_stdout_get_stdout(void);
    
    // Imported Functions from `wasi:cli/stderr@0.2.0-rc-2023-10-18`
    extern wasi_cli_0_2_0_rc_2023_10_18_stderr_own_output_stream_t wasi_cli_0_2_0_rc_2023_10_18_stderr_get_stderr(void);
    
    // Imported Functions from `wasi:cli/terminal-stdin@0.2.0-rc-2023-10-18`
    // If stdin is connected to a terminal, return a `terminal-input` handle
    // allowing further interaction with it.
    extern bool wasi_cli_0_2_0_rc_2023_10_18_terminal_stdin_get_terminal_stdin(wasi_cli_0_2_0_rc_2023_10_18_terminal_stdin_own_terminal_input_t *ret);
    
    // Imported Functions from `wasi:cli/terminal-stdout@0.2.0-rc-2023-10-18`
    // If stdout is connected to a terminal, return a `terminal-output` handle
    // allowing further interaction with it.
    extern bool wasi_cli_0_2_0_rc_2023_10_18_terminal_stdout_get_terminal_stdout(wasi_cli_0_2_0_rc_2023_10_18_terminal_stdout_own_terminal_output_t *ret);
    
    // Imported Functions from `wasi:cli/terminal-stderr@0.2.0-rc-2023-10-18`
    // If stderr is connected to a terminal, return a `terminal-output` handle
    // allowing further interaction with it.
    extern bool wasi_cli_0_2_0_rc_2023_10_18_terminal_stderr_get_terminal_stderr(wasi_cli_0_2_0_rc_2023_10_18_terminal_stderr_own_terminal_output_t *ret);
    
    // Exported Functions from `wasi:http/incoming-handler@0.2.0-rc-2023-10-18`
    void exports_wasi_http_0_2_0_rc_2023_10_18_incoming_handler_handle(exports_wasi_http_0_2_0_rc_2023_10_18_incoming_handler_own_incoming_request_t request, exports_wasi_http_0_2_0_rc_2023_10_18_incoming_handler_own_response_outparam_t response_out);
    
    // Helper Functions
    
    extern void wasi_io_0_2_0_rc_2023_10_18_poll_pollable_drop_own(wasi_io_0_2_0_rc_2023_10_18_poll_own_pollable_t handle);
    extern void wasi_io_0_2_0_rc_2023_10_18_poll_pollable_drop_borrow(wasi_io_0_2_0_rc_2023_10_18_poll_own_pollable_t handle);
    
    extern wasi_io_0_2_0_rc_2023_10_18_poll_borrow_pollable_t wasi_io_0_2_0_rc_2023_10_18_poll_borrow_pollable(wasi_io_0_2_0_rc_2023_10_18_poll_own_pollable_t handle);
    
    void wasi_io_0_2_0_rc_2023_10_18_poll_list_borrow_pollable_free(wasi_io_0_2_0_rc_2023_10_18_poll_list_borrow_pollable_t *ptr);
    
    void wasi_io_0_2_0_rc_2023_10_18_poll_list_u32_free(wasi_io_0_2_0_rc_2023_10_18_poll_list_u32_t *ptr);
    
    extern void wasi_io_0_2_0_rc_2023_10_18_streams_error_drop_own(wasi_io_0_2_0_rc_2023_10_18_streams_own_error_t handle);
    extern void wasi_io_0_2_0_rc_2023_10_18_streams_error_drop_borrow(wasi_io_0_2_0_rc_2023_10_18_streams_own_error_t handle);
    
    extern wasi_io_0_2_0_rc_2023_10_18_streams_borrow_error_t wasi_io_0_2_0_rc_2023_10_18_streams_borrow_error(wasi_io_0_2_0_rc_2023_10_18_streams_own_error_t handle);
    
    void wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_free(wasi_io_0_2_0_rc_2023_10_18_streams_stream_error_t *ptr);
    
    extern void wasi_io_0_2_0_rc_2023_10_18_streams_input_stream_drop_own(wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t handle);
    extern void wasi_io_0_2_0_rc_2023_10_18_streams_input_stream_drop_borrow(wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t handle);
    
    extern wasi_io_0_2_0_rc_2023_10_18_streams_borrow_input_stream_t wasi_io_0_2_0_rc_2023_10_18_streams_borrow_input_stream(wasi_io_0_2_0_rc_2023_10_18_streams_own_input_stream_t handle);
    
    extern void wasi_io_0_2_0_rc_2023_10_18_streams_output_stream_drop_own(wasi_io_0_2_0_rc_2023_10_18_streams_own_output_stream_t handle);
    extern void wasi_io_0_2_0_rc_2023_10_18_streams_output_stream_drop_borrow(wasi_io_0_2_0_rc_2023_10_18_streams_own_output_stream_t handle);
    
    extern wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream_t wasi_io_0_2_0_rc_2023_10_18_streams_borrow_output_stream(wasi_io_0_2_0_rc_2023_10_18_streams_own_output_stream_t handle);
    
    void wasi_io_0_2_0_rc_2023_10_18_streams_list_u8_free(wasi_io_0_2_0_rc_2023_10_18_streams_list_u8_t *ptr);
    
    void wasi_io_0_2_0_rc_2023_10_18_streams_result_list_u8_stream_error_free(wasi_io_0_2_0_rc_2023_10_18_streams_result_list_u8_stream_error_t *ptr);
    
    void wasi_io_0_2_0_rc_2023_10_18_streams_result_u64_stream_error_free(wasi_io_0_2_0_rc_2023_10_18_streams_result_u64_stream_error_t *ptr);
    
    void wasi_io_0_2_0_rc_2023_10_18_streams_result_void_stream_error_free(wasi_io_0_2_0_rc_2023_10_18_streams_result_void_stream_error_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_method_free(wasi_http_0_2_0_rc_2023_10_18_types_method_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_scheme_free(wasi_http_0_2_0_rc_2023_10_18_types_scheme_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_error_free(wasi_http_0_2_0_rc_2023_10_18_types_error_t *ptr);
    
    extern void wasi_http_0_2_0_rc_2023_10_18_types_fields_drop_own(wasi_http_0_2_0_rc_2023_10_18_types_own_fields_t handle);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_fields_drop_borrow(wasi_http_0_2_0_rc_2023_10_18_types_own_fields_t handle);
    
    extern wasi_http_0_2_0_rc_2023_10_18_types_borrow_fields_t wasi_http_0_2_0_rc_2023_10_18_types_borrow_fields(wasi_http_0_2_0_rc_2023_10_18_types_own_fields_t handle);
    
    extern void wasi_http_0_2_0_rc_2023_10_18_types_incoming_request_drop_own(wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_request_t handle);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_incoming_request_drop_borrow(wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_request_t handle);
    
    extern wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_request_t wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_request(wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_request_t handle);
    
    extern void wasi_http_0_2_0_rc_2023_10_18_types_outgoing_request_drop_own(wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_request_t handle);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_outgoing_request_drop_borrow(wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_request_t handle);
    
    extern wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_request_t wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_request(wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_request_t handle);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_option_u32_free(wasi_http_0_2_0_rc_2023_10_18_types_option_u32_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_request_options_free(wasi_http_0_2_0_rc_2023_10_18_types_request_options_t *ptr);
    
    extern void wasi_http_0_2_0_rc_2023_10_18_types_response_outparam_drop_own(wasi_http_0_2_0_rc_2023_10_18_types_own_response_outparam_t handle);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_response_outparam_drop_borrow(wasi_http_0_2_0_rc_2023_10_18_types_own_response_outparam_t handle);
    
    extern wasi_http_0_2_0_rc_2023_10_18_types_borrow_response_outparam_t wasi_http_0_2_0_rc_2023_10_18_types_borrow_response_outparam(wasi_http_0_2_0_rc_2023_10_18_types_own_response_outparam_t handle);
    
    extern void wasi_http_0_2_0_rc_2023_10_18_types_incoming_response_drop_own(wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_response_t handle);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_incoming_response_drop_borrow(wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_response_t handle);
    
    extern wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_response_t wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_response(wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_response_t handle);
    
    extern void wasi_http_0_2_0_rc_2023_10_18_types_incoming_body_drop_own(wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_body_t handle);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_incoming_body_drop_borrow(wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_body_t handle);
    
    extern wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_body_t wasi_http_0_2_0_rc_2023_10_18_types_borrow_incoming_body(wasi_http_0_2_0_rc_2023_10_18_types_own_incoming_body_t handle);
    
    extern void wasi_http_0_2_0_rc_2023_10_18_types_future_trailers_drop_own(wasi_http_0_2_0_rc_2023_10_18_types_own_future_trailers_t handle);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_future_trailers_drop_borrow(wasi_http_0_2_0_rc_2023_10_18_types_own_future_trailers_t handle);
    
    extern wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_trailers_t wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_trailers(wasi_http_0_2_0_rc_2023_10_18_types_own_future_trailers_t handle);
    
    extern void wasi_http_0_2_0_rc_2023_10_18_types_outgoing_response_drop_own(wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_response_t handle);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_outgoing_response_drop_borrow(wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_response_t handle);
    
    extern wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_response_t wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_response(wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_response_t handle);
    
    extern void wasi_http_0_2_0_rc_2023_10_18_types_outgoing_body_drop_own(wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_body_t handle);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_outgoing_body_drop_borrow(wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_body_t handle);
    
    extern wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_body_t wasi_http_0_2_0_rc_2023_10_18_types_borrow_outgoing_body(wasi_http_0_2_0_rc_2023_10_18_types_own_outgoing_body_t handle);
    
    extern void wasi_http_0_2_0_rc_2023_10_18_types_future_incoming_response_drop_own(wasi_http_0_2_0_rc_2023_10_18_types_own_future_incoming_response_t handle);
    extern void wasi_http_0_2_0_rc_2023_10_18_types_future_incoming_response_drop_borrow(wasi_http_0_2_0_rc_2023_10_18_types_own_future_incoming_response_t handle);
    
    extern wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_incoming_response_t wasi_http_0_2_0_rc_2023_10_18_types_borrow_future_incoming_response(wasi_http_0_2_0_rc_2023_10_18_types_own_future_incoming_response_t handle);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_list_u8_free(wasi_http_0_2_0_rc_2023_10_18_types_list_u8_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_tuple2_string_list_u8_free(wasi_http_0_2_0_rc_2023_10_18_types_tuple2_string_list_u8_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_list_tuple2_string_list_u8_free(wasi_http_0_2_0_rc_2023_10_18_types_list_tuple2_string_list_u8_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_list_list_u8_free(wasi_http_0_2_0_rc_2023_10_18_types_list_list_u8_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_option_string_free(wasi_http_0_2_0_rc_2023_10_18_types_option_string_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_option_scheme_free(wasi_http_0_2_0_rc_2023_10_18_types_option_scheme_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_result_own_incoming_body_void_free(wasi_http_0_2_0_rc_2023_10_18_types_result_own_incoming_body_void_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_result_own_outgoing_body_void_free(wasi_http_0_2_0_rc_2023_10_18_types_result_own_outgoing_body_void_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_result_own_outgoing_response_error_free(wasi_http_0_2_0_rc_2023_10_18_types_result_own_outgoing_response_error_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_result_own_input_stream_void_free(wasi_http_0_2_0_rc_2023_10_18_types_result_own_input_stream_void_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_result_own_trailers_error_free(wasi_http_0_2_0_rc_2023_10_18_types_result_own_trailers_error_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_option_result_own_trailers_error_free(wasi_http_0_2_0_rc_2023_10_18_types_option_result_own_trailers_error_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_result_own_output_stream_void_free(wasi_http_0_2_0_rc_2023_10_18_types_result_own_output_stream_void_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_option_own_trailers_free(wasi_http_0_2_0_rc_2023_10_18_types_option_own_trailers_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_result_own_incoming_response_error_free(wasi_http_0_2_0_rc_2023_10_18_types_result_own_incoming_response_error_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_result_result_own_incoming_response_error_void_free(wasi_http_0_2_0_rc_2023_10_18_types_result_result_own_incoming_response_error_void_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_types_option_result_result_own_incoming_response_error_void_free(wasi_http_0_2_0_rc_2023_10_18_types_option_result_result_own_incoming_response_error_void_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_request_options_free(wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_request_options_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_error_free(wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_error_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_option_request_options_free(wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_option_request_options_t *ptr);
    
    void wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_result_own_future_incoming_response_error_free(wasi_http_0_2_0_rc_2023_10_18_outgoing_handler_result_own_future_incoming_response_error_t *ptr);
    
    void fermyon_spin_2_0_0_llm_inferencing_model_free(fermyon_spin_2_0_0_llm_inferencing_model_t *ptr);
    
    void fermyon_spin_2_0_0_llm_error_free(fermyon_spin_2_0_0_llm_error_t *ptr);
    
    void fermyon_spin_2_0_0_llm_inferencing_result_free(fermyon_spin_2_0_0_llm_inferencing_result_t *ptr);
    
    void fermyon_spin_2_0_0_llm_embedding_model_free(fermyon_spin_2_0_0_llm_embedding_model_t *ptr);
    
    void fermyon_spin_2_0_0_llm_list_float32_free(fermyon_spin_2_0_0_llm_list_float32_t *ptr);
    
    void fermyon_spin_2_0_0_llm_list_list_float32_free(fermyon_spin_2_0_0_llm_list_list_float32_t *ptr);
    
    void fermyon_spin_2_0_0_llm_embeddings_result_free(fermyon_spin_2_0_0_llm_embeddings_result_t *ptr);
    
    void fermyon_spin_2_0_0_llm_option_inferencing_params_free(fermyon_spin_2_0_0_llm_option_inferencing_params_t *ptr);
    
    void fermyon_spin_2_0_0_llm_result_inferencing_result_error_free(fermyon_spin_2_0_0_llm_result_inferencing_result_error_t *ptr);
    
    void fermyon_spin_2_0_0_llm_list_string_free(fermyon_spin_2_0_0_llm_list_string_t *ptr);
    
    void fermyon_spin_2_0_0_llm_result_embeddings_result_error_free(fermyon_spin_2_0_0_llm_result_embeddings_result_error_t *ptr);
    
    void fermyon_spin_2_0_0_redis_error_free(fermyon_spin_2_0_0_redis_error_t *ptr);
    
    extern void fermyon_spin_2_0_0_redis_connection_drop_own(fermyon_spin_2_0_0_redis_own_connection_t handle);
    extern void fermyon_spin_2_0_0_redis_connection_drop_borrow(fermyon_spin_2_0_0_redis_own_connection_t handle);
    
    extern fermyon_spin_2_0_0_redis_borrow_connection_t fermyon_spin_2_0_0_redis_borrow_connection(fermyon_spin_2_0_0_redis_own_connection_t handle);
    
    void fermyon_spin_2_0_0_redis_payload_free(fermyon_spin_2_0_0_redis_payload_t *ptr);
    
    void fermyon_spin_2_0_0_redis_redis_parameter_free(fermyon_spin_2_0_0_redis_redis_parameter_t *ptr);
    
    void fermyon_spin_2_0_0_redis_redis_result_free(fermyon_spin_2_0_0_redis_redis_result_t *ptr);
    
    void fermyon_spin_2_0_0_redis_result_own_connection_error_free(fermyon_spin_2_0_0_redis_result_own_connection_error_t *ptr);
    
    void fermyon_spin_2_0_0_redis_result_void_error_free(fermyon_spin_2_0_0_redis_result_void_error_t *ptr);
    
    void fermyon_spin_2_0_0_redis_option_payload_free(fermyon_spin_2_0_0_redis_option_payload_t *ptr);
    
    void fermyon_spin_2_0_0_redis_result_option_payload_error_free(fermyon_spin_2_0_0_redis_result_option_payload_error_t *ptr);
    
    void fermyon_spin_2_0_0_redis_result_s64_error_free(fermyon_spin_2_0_0_redis_result_s64_error_t *ptr);
    
    void fermyon_spin_2_0_0_redis_result_u32_error_free(fermyon_spin_2_0_0_redis_result_u32_error_t *ptr);
    
    void fermyon_spin_2_0_0_redis_result_list_string_error_free(fermyon_spin_2_0_0_redis_result_list_string_error_t *ptr);
    
    void fermyon_spin_2_0_0_redis_list_redis_parameter_free(fermyon_spin_2_0_0_redis_list_redis_parameter_t *ptr);
    
    void fermyon_spin_2_0_0_redis_list_redis_result_free(fermyon_spin_2_0_0_redis_list_redis_result_t *ptr);
    
    void fermyon_spin_2_0_0_redis_result_list_redis_result_error_free(fermyon_spin_2_0_0_redis_result_list_redis_result_error_t *ptr);
    
    void fermyon_spin_2_0_0_rdbms_types_error_free(fermyon_spin_2_0_0_rdbms_types_error_t *ptr);
    
    void fermyon_spin_2_0_0_rdbms_types_list_u8_free(fermyon_spin_2_0_0_rdbms_types_list_u8_t *ptr);
    
    void fermyon_spin_2_0_0_rdbms_types_db_value_free(fermyon_spin_2_0_0_rdbms_types_db_value_t *ptr);
    
    void fermyon_spin_2_0_0_rdbms_types_parameter_value_free(fermyon_spin_2_0_0_rdbms_types_parameter_value_t *ptr);
    
    void fermyon_spin_2_0_0_rdbms_types_column_free(fermyon_spin_2_0_0_rdbms_types_column_t *ptr);
    
    void fermyon_spin_2_0_0_rdbms_types_row_free(fermyon_spin_2_0_0_rdbms_types_row_t *ptr);
    
    void fermyon_spin_2_0_0_rdbms_types_list_column_free(fermyon_spin_2_0_0_rdbms_types_list_column_t *ptr);
    
    void fermyon_spin_2_0_0_rdbms_types_list_row_free(fermyon_spin_2_0_0_rdbms_types_list_row_t *ptr);
    
    void fermyon_spin_2_0_0_rdbms_types_row_set_free(fermyon_spin_2_0_0_rdbms_types_row_set_t *ptr);
    
    void fermyon_spin_2_0_0_postgres_parameter_value_free(fermyon_spin_2_0_0_postgres_parameter_value_t *ptr);
    
    void fermyon_spin_2_0_0_postgres_row_set_free(fermyon_spin_2_0_0_postgres_row_set_t *ptr);
    
    void fermyon_spin_2_0_0_postgres_error_free(fermyon_spin_2_0_0_postgres_error_t *ptr);
    
    extern void fermyon_spin_2_0_0_postgres_connection_drop_own(fermyon_spin_2_0_0_postgres_own_connection_t handle);
    extern void fermyon_spin_2_0_0_postgres_connection_drop_borrow(fermyon_spin_2_0_0_postgres_own_connection_t handle);
    
    extern fermyon_spin_2_0_0_postgres_borrow_connection_t fermyon_spin_2_0_0_postgres_borrow_connection(fermyon_spin_2_0_0_postgres_own_connection_t handle);
    
    void fermyon_spin_2_0_0_postgres_result_own_connection_error_free(fermyon_spin_2_0_0_postgres_result_own_connection_error_t *ptr);
    
    void fermyon_spin_2_0_0_postgres_list_parameter_value_free(fermyon_spin_2_0_0_postgres_list_parameter_value_t *ptr);
    
    void fermyon_spin_2_0_0_postgres_result_row_set_error_free(fermyon_spin_2_0_0_postgres_result_row_set_error_t *ptr);
    
    void fermyon_spin_2_0_0_postgres_result_u64_error_free(fermyon_spin_2_0_0_postgres_result_u64_error_t *ptr);
    
    void fermyon_spin_2_0_0_mysql_parameter_value_free(fermyon_spin_2_0_0_mysql_parameter_value_t *ptr);
    
    void fermyon_spin_2_0_0_mysql_row_set_free(fermyon_spin_2_0_0_mysql_row_set_t *ptr);
    
    void fermyon_spin_2_0_0_mysql_error_free(fermyon_spin_2_0_0_mysql_error_t *ptr);
    
    extern void fermyon_spin_2_0_0_mysql_connection_drop_own(fermyon_spin_2_0_0_mysql_own_connection_t handle);
    extern void fermyon_spin_2_0_0_mysql_connection_drop_borrow(fermyon_spin_2_0_0_mysql_own_connection_t handle);
    
    extern fermyon_spin_2_0_0_mysql_borrow_connection_t fermyon_spin_2_0_0_mysql_borrow_connection(fermyon_spin_2_0_0_mysql_own_connection_t handle);
    
    void fermyon_spin_2_0_0_mysql_result_own_connection_error_free(fermyon_spin_2_0_0_mysql_result_own_connection_error_t *ptr);
    
    void fermyon_spin_2_0_0_mysql_list_parameter_value_free(fermyon_spin_2_0_0_mysql_list_parameter_value_t *ptr);
    
    void fermyon_spin_2_0_0_mysql_result_row_set_error_free(fermyon_spin_2_0_0_mysql_result_row_set_error_t *ptr);
    
    void fermyon_spin_2_0_0_mysql_result_void_error_free(fermyon_spin_2_0_0_mysql_result_void_error_t *ptr);
    
    extern void fermyon_spin_2_0_0_sqlite_connection_drop_own(fermyon_spin_2_0_0_sqlite_own_connection_t handle);
    extern void fermyon_spin_2_0_0_sqlite_connection_drop_borrow(fermyon_spin_2_0_0_sqlite_own_connection_t handle);
    
    extern fermyon_spin_2_0_0_sqlite_borrow_connection_t fermyon_spin_2_0_0_sqlite_borrow_connection(fermyon_spin_2_0_0_sqlite_own_connection_t handle);
    
    void fermyon_spin_2_0_0_sqlite_error_free(fermyon_spin_2_0_0_sqlite_error_t *ptr);
    
    void fermyon_spin_2_0_0_sqlite_value_free(fermyon_spin_2_0_0_sqlite_value_t *ptr);
    
    void fermyon_spin_2_0_0_sqlite_list_value_free(fermyon_spin_2_0_0_sqlite_list_value_t *ptr);
    
    void fermyon_spin_2_0_0_sqlite_row_result_free(fermyon_spin_2_0_0_sqlite_row_result_t *ptr);
    
    void fermyon_spin_2_0_0_sqlite_list_row_result_free(fermyon_spin_2_0_0_sqlite_list_row_result_t *ptr);
    
    void fermyon_spin_2_0_0_sqlite_query_result_free(fermyon_spin_2_0_0_sqlite_query_result_t *ptr);
    
    void fermyon_spin_2_0_0_sqlite_result_own_connection_error_free(fermyon_spin_2_0_0_sqlite_result_own_connection_error_t *ptr);
    
    void fermyon_spin_2_0_0_sqlite_result_query_result_error_free(fermyon_spin_2_0_0_sqlite_result_query_result_error_t *ptr);
    
    extern void fermyon_spin_2_0_0_key_value_store_drop_own(fermyon_spin_2_0_0_key_value_own_store_t handle);
    extern void fermyon_spin_2_0_0_key_value_store_drop_borrow(fermyon_spin_2_0_0_key_value_own_store_t handle);
    
    extern fermyon_spin_2_0_0_key_value_borrow_store_t fermyon_spin_2_0_0_key_value_borrow_store(fermyon_spin_2_0_0_key_value_own_store_t handle);
    
    void fermyon_spin_2_0_0_key_value_error_free(fermyon_spin_2_0_0_key_value_error_t *ptr);
    
    void fermyon_spin_2_0_0_key_value_result_own_store_error_free(fermyon_spin_2_0_0_key_value_result_own_store_error_t *ptr);
    
    void fermyon_spin_2_0_0_key_value_option_list_u8_free(fermyon_spin_2_0_0_key_value_option_list_u8_t *ptr);
    
    void fermyon_spin_2_0_0_key_value_result_option_list_u8_error_free(fermyon_spin_2_0_0_key_value_result_option_list_u8_error_t *ptr);
    
    void fermyon_spin_2_0_0_key_value_result_void_error_free(fermyon_spin_2_0_0_key_value_result_void_error_t *ptr);
    
    void fermyon_spin_2_0_0_key_value_result_bool_error_free(fermyon_spin_2_0_0_key_value_result_bool_error_t *ptr);
    
    void fermyon_spin_2_0_0_key_value_result_list_string_error_free(fermyon_spin_2_0_0_key_value_result_list_string_error_t *ptr);
    
    void fermyon_spin_2_0_0_variables_error_free(fermyon_spin_2_0_0_variables_error_t *ptr);
    
    void fermyon_spin_2_0_0_variables_result_string_error_free(fermyon_spin_2_0_0_variables_result_string_error_t *ptr);
    
    void wasi_clocks_0_2_0_rc_2023_10_18_timezone_timezone_display_free(wasi_clocks_0_2_0_rc_2023_10_18_timezone_timezone_display_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_access_type_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_access_type_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_option_datetime_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_option_datetime_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_stat_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_stat_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_new_timestamp_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_new_timestamp_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_directory_entry_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_directory_entry_t *ptr);
    
    extern void wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_drop_own(wasi_filesystem_0_2_0_rc_2023_10_18_types_own_descriptor_t handle);
    extern void wasi_filesystem_0_2_0_rc_2023_10_18_types_descriptor_drop_borrow(wasi_filesystem_0_2_0_rc_2023_10_18_types_own_descriptor_t handle);
    
    extern wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor_t wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_descriptor(wasi_filesystem_0_2_0_rc_2023_10_18_types_own_descriptor_t handle);
    
    extern void wasi_filesystem_0_2_0_rc_2023_10_18_types_directory_entry_stream_drop_own(wasi_filesystem_0_2_0_rc_2023_10_18_types_own_directory_entry_stream_t handle);
    extern void wasi_filesystem_0_2_0_rc_2023_10_18_types_directory_entry_stream_drop_borrow(wasi_filesystem_0_2_0_rc_2023_10_18_types_own_directory_entry_stream_t handle);
    
    extern wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_directory_entry_stream_t wasi_filesystem_0_2_0_rc_2023_10_18_types_borrow_directory_entry_stream(wasi_filesystem_0_2_0_rc_2023_10_18_types_own_directory_entry_stream_t handle);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_input_stream_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_input_stream_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_output_stream_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_output_stream_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_void_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_void_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_descriptor_flags_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_descriptor_flags_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_descriptor_type_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_descriptor_type_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_list_u8_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_list_u8_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_tuple2_list_u8_bool_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_tuple2_list_u8_bool_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_tuple2_list_u8_bool_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_tuple2_list_u8_bool_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_filesize_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_filesize_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_directory_entry_stream_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_directory_entry_stream_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_descriptor_stat_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_descriptor_stat_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_descriptor_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_own_descriptor_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_string_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_string_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_metadata_hash_value_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_metadata_hash_value_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_option_directory_entry_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_option_directory_entry_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_result_option_directory_entry_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_result_option_directory_entry_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_types_option_error_code_free(wasi_filesystem_0_2_0_rc_2023_10_18_types_option_error_code_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_preopens_tuple2_own_descriptor_string_free(wasi_filesystem_0_2_0_rc_2023_10_18_preopens_tuple2_own_descriptor_string_t *ptr);
    
    void wasi_filesystem_0_2_0_rc_2023_10_18_preopens_list_tuple2_own_descriptor_string_free(wasi_filesystem_0_2_0_rc_2023_10_18_preopens_list_tuple2_own_descriptor_string_t *ptr);
    
    extern void wasi_sockets_0_2_0_rc_2023_10_18_network_network_drop_own(wasi_sockets_0_2_0_rc_2023_10_18_network_own_network_t handle);
    extern void wasi_sockets_0_2_0_rc_2023_10_18_network_network_drop_borrow(wasi_sockets_0_2_0_rc_2023_10_18_network_own_network_t handle);
    
    extern wasi_sockets_0_2_0_rc_2023_10_18_network_borrow_network_t wasi_sockets_0_2_0_rc_2023_10_18_network_borrow_network(wasi_sockets_0_2_0_rc_2023_10_18_network_own_network_t handle);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_network_ip_address_free(wasi_sockets_0_2_0_rc_2023_10_18_network_ip_address_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_network_ip_socket_address_free(wasi_sockets_0_2_0_rc_2023_10_18_network_ip_socket_address_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_ip_address_free(wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_ip_address_t *ptr);
    
    extern void wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_resolve_address_stream_drop_own(wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_own_resolve_address_stream_t handle);
    extern void wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_resolve_address_stream_drop_borrow(wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_own_resolve_address_stream_t handle);
    
    extern wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_borrow_resolve_address_stream_t wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_borrow_resolve_address_stream(wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_own_resolve_address_stream_t handle);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_option_ip_address_family_free(wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_option_ip_address_family_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_result_own_resolve_address_stream_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_result_own_resolve_address_stream_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_option_ip_address_free(wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_option_ip_address_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_result_option_ip_address_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_ip_name_lookup_result_option_ip_address_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_tcp_ip_socket_address_free(wasi_sockets_0_2_0_rc_2023_10_18_tcp_ip_socket_address_t *ptr);
    
    extern void wasi_sockets_0_2_0_rc_2023_10_18_tcp_tcp_socket_drop_own(wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_tcp_socket_t handle);
    extern void wasi_sockets_0_2_0_rc_2023_10_18_tcp_tcp_socket_drop_borrow(wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_tcp_socket_t handle);
    
    extern wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket_t wasi_sockets_0_2_0_rc_2023_10_18_tcp_borrow_tcp_socket(wasi_sockets_0_2_0_rc_2023_10_18_tcp_own_tcp_socket_t handle);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_void_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_void_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_tuple2_own_input_stream_own_output_stream_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_tuple2_own_input_stream_own_output_stream_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_tuple3_own_tcp_socket_own_input_stream_own_output_stream_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_tuple3_own_tcp_socket_own_input_stream_own_output_stream_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_ip_socket_address_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_ip_socket_address_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_bool_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_bool_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_u8_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_u8_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_u64_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_tcp_result_u64_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_result_own_tcp_socket_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_tcp_create_socket_result_own_tcp_socket_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_udp_ip_socket_address_free(wasi_sockets_0_2_0_rc_2023_10_18_udp_ip_socket_address_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_udp_list_u8_free(wasi_sockets_0_2_0_rc_2023_10_18_udp_list_u8_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_udp_datagram_free(wasi_sockets_0_2_0_rc_2023_10_18_udp_datagram_t *ptr);
    
    extern void wasi_sockets_0_2_0_rc_2023_10_18_udp_udp_socket_drop_own(wasi_sockets_0_2_0_rc_2023_10_18_udp_own_udp_socket_t handle);
    extern void wasi_sockets_0_2_0_rc_2023_10_18_udp_udp_socket_drop_borrow(wasi_sockets_0_2_0_rc_2023_10_18_udp_own_udp_socket_t handle);
    
    extern wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket_t wasi_sockets_0_2_0_rc_2023_10_18_udp_borrow_udp_socket(wasi_sockets_0_2_0_rc_2023_10_18_udp_own_udp_socket_t handle);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_udp_result_void_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_udp_result_void_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_udp_list_datagram_free(wasi_sockets_0_2_0_rc_2023_10_18_udp_list_datagram_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_udp_result_list_datagram_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_udp_result_list_datagram_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_udp_result_u64_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_udp_result_u64_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_udp_result_ip_socket_address_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_udp_result_ip_socket_address_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_udp_result_bool_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_udp_result_bool_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_udp_result_u8_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_udp_result_u8_error_code_t *ptr);
    
    void wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_result_own_udp_socket_error_code_free(wasi_sockets_0_2_0_rc_2023_10_18_udp_create_socket_result_own_udp_socket_error_code_t *ptr);
    
    void wasi_random_0_2_0_rc_2023_10_18_random_list_u8_free(wasi_random_0_2_0_rc_2023_10_18_random_list_u8_t *ptr);
    
    void wasi_cli_0_2_0_rc_2023_10_18_environment_tuple2_string_string_free(wasi_cli_0_2_0_rc_2023_10_18_environment_tuple2_string_string_t *ptr);
    
    void wasi_cli_0_2_0_rc_2023_10_18_environment_list_tuple2_string_string_free(wasi_cli_0_2_0_rc_2023_10_18_environment_list_tuple2_string_string_t *ptr);
    
    void wasi_cli_0_2_0_rc_2023_10_18_environment_list_string_free(wasi_cli_0_2_0_rc_2023_10_18_environment_list_string_t *ptr);
    
    void wasi_cli_0_2_0_rc_2023_10_18_environment_option_string_free(wasi_cli_0_2_0_rc_2023_10_18_environment_option_string_t *ptr);
    
    void wasi_cli_0_2_0_rc_2023_10_18_exit_result_void_void_free(wasi_cli_0_2_0_rc_2023_10_18_exit_result_void_void_t *ptr);
    
    extern void wasi_cli_0_2_0_rc_2023_10_18_terminal_input_terminal_input_drop_own(wasi_cli_0_2_0_rc_2023_10_18_terminal_input_own_terminal_input_t handle);
    extern void wasi_cli_0_2_0_rc_2023_10_18_terminal_input_terminal_input_drop_borrow(wasi_cli_0_2_0_rc_2023_10_18_terminal_input_own_terminal_input_t handle);
    
    extern wasi_cli_0_2_0_rc_2023_10_18_terminal_input_borrow_terminal_input_t wasi_cli_0_2_0_rc_2023_10_18_terminal_input_borrow_terminal_input(wasi_cli_0_2_0_rc_2023_10_18_terminal_input_own_terminal_input_t handle);
    
    extern void wasi_cli_0_2_0_rc_2023_10_18_terminal_output_terminal_output_drop_own(wasi_cli_0_2_0_rc_2023_10_18_terminal_output_own_terminal_output_t handle);
    extern void wasi_cli_0_2_0_rc_2023_10_18_terminal_output_terminal_output_drop_borrow(wasi_cli_0_2_0_rc_2023_10_18_terminal_output_own_terminal_output_t handle);
    
    extern wasi_cli_0_2_0_rc_2023_10_18_terminal_output_borrow_terminal_output_t wasi_cli_0_2_0_rc_2023_10_18_terminal_output_borrow_terminal_output(wasi_cli_0_2_0_rc_2023_10_18_terminal_output_own_terminal_output_t handle);
    
    void wasi_cli_0_2_0_rc_2023_10_18_terminal_stdin_option_own_terminal_input_free(wasi_cli_0_2_0_rc_2023_10_18_terminal_stdin_option_own_terminal_input_t *ptr);
    
    void wasi_cli_0_2_0_rc_2023_10_18_terminal_stdout_option_own_terminal_output_free(wasi_cli_0_2_0_rc_2023_10_18_terminal_stdout_option_own_terminal_output_t *ptr);
    
    void wasi_cli_0_2_0_rc_2023_10_18_terminal_stderr_option_own_terminal_output_free(wasi_cli_0_2_0_rc_2023_10_18_terminal_stderr_option_own_terminal_output_t *ptr);
    
    // Transfers ownership of `s` into the string `ret`
    void http_trigger_string_set(http_trigger_string_t *ret, char*s);
    
    // Creates a copy of the input nul-terminate string `s` and
    // stores it into the component model string `ret`.
    void http_trigger_string_dup(http_trigger_string_t *ret, const char*s);
    
    // Deallocates the string pointed to by `ret`, deallocating
    // the memory behind the string.
    void http_trigger_string_free(http_trigger_string_t *ret);
    
    #ifdef __cplusplus
  }
  #endif
  #endif
  